<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xbw的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-07T00:32:28.290Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xbw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML和CSS回顾</title>
    <link href="http://yoursite.com/2020/08/23/HTML-CSS-Review/"/>
    <id>http://yoursite.com/2020/08/23/HTML-CSS-Review/</id>
    <published>2020-08-23T01:58:00.000Z</published>
    <updated>2020-09-07T00:32:28.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="完整的HTML结构"><a href="#完整的HTML结构" class="headerlink" title="完整的HTML结构"></a>完整的HTML结构</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;  </code></pre><ul><li>文档声明（<code>&lt;!DOCTYPE html&gt;</code>）<ul><li>告诉浏览器当前页面为HTML5页面，让浏览器用HTML5的标准去解析HTML文档</li><li>放在HTML文档的最前面，不能省略，否则会出现兼容性问题</li><li>HTML5的文档声明比HTML4.01、XHTML1.0简洁</li></ul></li><li>html元素<ul><li>是HTML文档的根元素，一个文档中只能有一个，其他元素都是它的后代元素</li><li>W3C标准建议为html增加一个lang属性，作用是指定当前页面使用的语言，帮助翻译工具确定使用的翻译规则，帮助语音合成工具确定使用的（lang=”en”表示文档语言为英文，lang=”zh”表示文档语言为中文）</li></ul></li><li>head元素（放一些元数据）<ul><li>元数据<ul><li>用来描述数据的数据</li><li>对网页进行一些基本设置：字符编码、网页标题、网页图标</li></ul></li><li>title元素<ul><li>设置网站的标题</li></ul></li><li>meta元素<ul><li>设置网页的字符编码：不设置或设置错误会导致乱码<br><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></li></ul></li><li>style元素：样式</li><li>link元素：引入外部css文件、设置网站图标  <pre><code>// stylesheet表示引入样式&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;// icon表示引入图标 type可不写&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;</code></pre></li><li>base元素</li><li>script元素</li><li>noscript元素</li></ul></li><li>body元素（包含网页的具体内容和结构）</li></ul><hr><h2 id="HTML基本元素"><a href="#HTML基本元素" class="headerlink" title="HTML基本元素"></a>HTML基本元素</h2><ul><li><p>h元素  </p><ul><li>表示网页的标题</li><li>h1~h6共规定了6个等级的标题</li><li>演示<pre><code>&lt;h1&gt;hello world&lt;/h1&gt;&lt;h2&gt;hello world&lt;/h2&gt;&lt;h3&gt;hello world&lt;/h3&gt;&lt;h4&gt;hello world&lt;/h4&gt;&lt;h5&gt;hello world&lt;/h5&gt;&lt;h6&gt;hello world&lt;/h6&gt;</code></pre></li></ul></li><li><p>p元素</p><ul><li>表示段落</li><li>演示<pre><code>&lt;p&gt;我在这头，你在那头&lt;/p&gt;</code></pre></li></ul></li><li><p>strong元素</p><ul><li>表示加粗、强调效果</li><li>演示<pre><code>&lt;p&gt;天行健，君子以&lt;strong&gt;自强不息&lt;/strong&gt;，地势坤，君子以&lt;strong&gt;厚德载物&lt;/strong&gt;&lt;/p&gt;</code></pre></li></ul></li><li><p>h元素和SEO优化（搜索引擎优化）</p><ul><li>SEO优化（百度、搜狗、360、Google搜索引擎）</li><li>h元素有助于网站的SEO优化，可以促进关键词排名</li><li>建议在网页中最多只有一个h1元素</li></ul></li><li><p>code元素（代码元素）</p><ul><li>特点：将字体设置为等宽字体</li></ul></li><li><p>br元素（换行）</p></li><li><p>hr元素（分割线）</p></li><li><p>字符实体</p><ul><li>小于号（&lt;）：<code>&amp;lt;</code></li><li>大于号（&gt;）：<code>&amp;gt;</code></li><li>空格：<code>&amp;nbsp;</code></li><li>双引号（”）：<code>&amp;quot;</code></li><li>单引号（’）：<code>&amp;apos;</code></li></ul></li><li><p>span元素</p><ul><li>演示<br><code>&lt;span&gt;我是span标签&lt;/span&gt;</code></li></ul></li><li><p>div元素</p><ul><li>演示<pre><code>&lt;div&gt;  &lt;h2&gt;hello world&lt;/h2&gt;  &lt;p&gt;p标签&lt;/p&gt;&lt;/div&gt;</code></pre></li></ul></li><li><p>img标签</p><ul><li>该标签为单标签</li><li>常见图片格式<ul><li>png：静态图片，支持透明</li><li>jpg（jpeg）：静态图片，不支持透明</li><li>gif：动态图片，支持透明</li><li>webp</li></ul></li><li>src属性：指定图片路径（绝对路径、相对路径）</li><li>alt属性：当图片失效（加载失败）时显示的文本</li><li>width属性：设置图片宽度</li></ul></li><li><p>a元素</p><ul><li><p>用于定义超链接，打开新的URL</p></li><li><p>href属性：指定要打开的URL</p></li><li><p>target属性</p><ul><li>_self（默认值）：在当前页面打开</li><li>_blank：在新的页面打开</li><li>_parent：需要和iframe一起使用才具有效果</li><li>_top：需要和iframe一起使用才具有效果</li><li>具体的name：需要和iframe一起使用才具有效果</li></ul></li><li><p>演示  </p><pre><code>&lt;div id=&quot;top&quot;&gt;顶端内容&lt;/div&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt;// 锚点链接 通过id到达指定位置&lt;a href=&quot;#top&quot;&gt;回到顶端&lt;/a&gt;// 伪链接 不指定具体跳转地址，暂时不做任何事情&lt;a href=&quot;#&quot; onclick=&quot;return false;&quot;&gt;伪链接一&lt;/a&gt;&lt;a href=&quot;javascript:;&quot;&gt;伪链接二&lt;/a&gt;</code></pre></li></ul></li><li><p>a元素和base元素结合使用</p><ul><li>演示<pre><code>&lt;head&gt;  &lt;!--抽取--&gt;  &lt;base href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;a href=&quot;&quot;&gt;百度一下&lt;/a&gt;  &lt;a href=&quot;/s?wd=vue&quot;&gt;搜索&lt;/a&gt;  &lt;!--不会拼接--&gt;  &lt;a href=&quot;https://www.taobao.com&quot;&gt;淘宝一下&lt;/a&gt;&lt;/body&gt;</code></pre></li></ul></li><li><p>iframe元素</p><ul><li>演示<pre><code>&lt;iframe     src=&quot;https://www.baidu.com&quot;     width=&quot;1000&quot;     height=&quot;500&quot;     frameborder=&quot;1&quot;&gt;&lt;/iframe&gt;</code></pre></li></ul></li><li><p>URL（统一资源定位符 ）</p><ul><li>资源的地址、位置，具有唯一性</li><li>协议://主机地址（域名或IP地址）:端口/路径?查询#锚点位置</li></ul></li><li><p>标签语义化（使用最适合的标签做最适合的事情）</p><ul><li>方便代码维护</li><li>减少开发者之间的沟通成本</li><li>让搜索引擎正确识别重要信息</li></ul></li></ul><hr><h1 id="CSS（层叠样式表）"><a href="#CSS（层叠样式表）" class="headerlink" title="CSS（层叠样式表）"></a>CSS（层叠样式表）</h1><h2 id="CSS引入的三种方式"><a href="#CSS引入的三种方式" class="headerlink" title="CSS引入的三种方式"></a>CSS引入的三种方式</h2><ul><li>内联样式（inline style）<pre><code>&lt;h1 style=&quot;font-size: 50px;color: red&quot;&gt;网页的标题&lt;/h1&gt;</code></pre></li><li>文档样式表（document style sheet）、内嵌样式表（embed style sheet）<pre><code>&lt;style&gt;  h1 {    color: red;    font-size: 40px;  }&lt;/style&gt;</code></pre></li><li>外部样式表（external style sheet）<pre><code>// 外部引入样式文件&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</code></pre></li></ul><hr><h2 id="CSS编码和import引入"><a href="#CSS编码和import引入" class="headerlink" title="CSS编码和import引入"></a>CSS编码和import引入</h2><ul><li>CSS编码<pre><code>// 给外部css文件指定编码@charset &quot;utf-8&quot;;</code></pre></li><li>import引入外部css文件<pre><code>&lt;style&gt;  // 可以引入多个外部css文件 比之link引入效率较低  @import url(&quot;外部css路径&quot;);  color: blue;&lt;/style&gt;</code></pre></li></ul><hr><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ul><li><p>通配选择器（通配符，遍历）</p><pre><code>&lt;style&gt;  * {    margin: 0;    padding: 0;    font-size: 12px;  }&lt;/style&gt;</code></pre></li><li><p>标签选择器</p><pre><code>&lt;style&gt;  div {    width: 200px;    height: 100px;  }&lt;/style&gt; </code></pre></li><li><p>类选择器</p><pre><code>&lt;style&gt;  .box {    background-color: red;  }&lt;/style&gt;</code></pre></li><li><p>id选择器</p><pre><code>#box {  background-color: blue;}</code></pre></li><li><p>属性选择器</p><pre><code>&lt;div title=&quot;one div&quot;&gt;我是div&lt;/div&gt;&lt;p title=&quot;one p&quot;&gt;我是p&lt;/p&gt;&lt;style&gt;  /*  [title=&quot;div元素&quot;] {    color: red;  }  */  // 只要包含one  [title*=&quot;one&quot;] {    color: red;  }  // 以one开头  [title^=&quot;one&quot;] {    color: red;  }  // 以one结尾  [title$=&quot;one&quot;] {    color: red;  }&lt;/style&gt;</code></pre></li><li><p>后代选择器</p><pre><code>&lt;div&gt;  &lt;span&gt;1&lt;/span&gt;  &lt;p&gt;    &lt;span&gt;2&lt;/span&gt;  &lt;/p&gt;&lt;/div&gt;&lt;style&gt;  div span {    color: red;   }&lt;/style&gt;// 结果是 1 2变红&lt;style&gt;  div &gt; span {    color: red;  }&lt;/style&gt;// 结果是 1变红</code></pre></li><li><p>兄弟选择器</p><pre><code>// 后面紧挨着的元素&lt;span&gt;1&lt;/span&gt;&lt;div&gt;  &lt;span&gt;2&lt;/span&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;style&gt;  div+span {    color: red;  }&lt;/style&gt;// 只有 3变红&lt;style&gt;  div~span {    color: red;  }&lt;/style&gt;// 3 4变红</code></pre></li><li><p>交集选择器和并集选择器</p><pre><code>&lt;div class=&quot;box&quot; title=&quot;test&quot;&gt;&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;style&gt;  // 交集选择器  div.box[title=&quot;test&quot;] {    width: 200px;    height: 200px;  }  .box, #content {    color: red;  }&lt;/style&gt;</code></pre></li><li><p>伪类选择器</p><ul><li>动态伪类<pre><code>&lt;a href=&quot;#&quot;&gt;链接&lt;/a&gt;&lt;style&gt;  // 未访问的链接  a:link {    color: red;  }  // 已访问的链接  a:visited {    color: blue;  }  // 获取焦点  a:focus {    background-color: red;  }  // 鼠标挪到链接 必须放在link和visited的后面才会生效  a:hover {    color: green;  }  // 鼠标在链接上按住未松手 必须放在hover后面才能生效  a:active {    color: yellow;  } &lt;/style&gt;</code></pre></li><li>目标伪类<pre><code>&lt;a href=&quot;#title&quot;&gt;标题&lt;/a&gt;&lt;h2 id=&quot;title&quot;&gt;标题&lt;/h2&gt;&lt;style&gt;  :target {    color: red;  }&lt;/style&gt;</code></pre></li><li>语言伪类</li><li>元素状态伪类<pre><code>&lt;button disabled&gt;按钮&lt;/button&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;style&gt;  :disabled {    color: red;  }&lt;/style&gt;</code></pre></li><li>结构伪类<pre><code>&lt;div class=&quot;box&quot;&gt;  &lt;p&gt;1&lt;/p&gt;  &lt;p&gt;2&lt;/p&gt;  &lt;p&gt;3&lt;/p&gt;  &lt;p&gt;4&lt;/p&gt;&lt;/div&gt;&lt;style&gt;  // 2变成红色  .box:nth-child(2) {    color: red;  }  // 所有偶数变红 even  .box:nth-child(2n) {    color: red;  }  // 所有奇数变红 odd  .box:nth-child(2n+1) {    color: red;  }  // 倒数第一个元素变红  .box:nth-last-child(1) {    color: red;  }  .box:nth-of-type(1) {    color: blue;  }&lt;/style&gt;</code></pre></li><li>否定伪类<pre><code>&lt;div&gt;div元素&lt;/div&gt;&lt;p&gt;p元素&lt;/p&gt;&lt;p&gt;p元素&lt;/p&gt;&lt;span&gt;span元素&lt;/span&gt;&lt;style&gt;  body :not(div) {    color: red;  }&lt;/style&gt;</code></pre></li></ul></li></ul><hr><h2 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h2><ul><li>first-line</li><li>first-letter</li><li>before</li><li>after</li></ul><hr><h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><ul><li><code>text-decoration</code><ul><li>none 无下划线</li><li>underline 下划线</li><li>overline 上划线</li><li>line-through 删除线</li></ul></li><li><code>letter-spacing</code> 字母间间距</li><li><code>word-spacing</code> 单词间间距</li><li><code>text-transform</code> 大小写转换<ul><li>capitalize 首字母大写</li><li>uppercase 大写</li><li>lowercase 小写</li><li>none 无</li></ul></li><li><code>text-indent</code> 设置第一行缩进</li><li><code>text-align</code> 设置元素内容在元素中水平对齐方式<ul><li>left 左对齐</li><li>right 右对齐</li><li>center 居中显示</li><li>justify 左右两端对齐（对最后一行无效果）</li></ul></li><li><code>font-size</code> 设置字体大小</li><li><code>font-family</code> 设置字体名称<pre><code>p {  // 可设置多个字体   font-family: &#39;微软雅黑&#39;,arial;}</code></pre></li><li><code>font-weight</code> 设置文字的粗细（可以是具体值）<ul><li>bold 加粗 相当于700</li><li>normal 常规 相当于400</li></ul></li><li><code>font-style</code> 设置文字的样式<ul><li>normal 常规 </li><li>italic 斜体（font-family这种字体支持斜体）</li><li>oblique 斜体（让文字倾斜）</li></ul></li><li><code>font-varient</code>  </li><li><code>line-height</code> 设置行高（两行文字基线baseline之间的距离）</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;完整的HTML结构&quot;&gt;&lt;a href=&quot;#完整的HTML结构&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="-HTML-CSS回顾" scheme="http://yoursite.com/categories/HTML-CSS%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="-HTML-CSS回顾" scheme="http://yoursite.com/tags/HTML-CSS%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2020/08/21/cross-domain/"/>
    <id>http://yoursite.com/2020/08/21/cross-domain/</id>
    <published>2020-08-21T03:56:38.000Z</published>
    <updated>2020-08-22T11:47:55.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域（非同源策略请求）"><a href="#跨域（非同源策略请求）" class="headerlink" title="跨域（非同源策略请求）"></a>跨域（非同源策略请求）</h1><h2 id="广义的跨域"><a href="#广义的跨域" class="headerlink" title="广义的跨域"></a>广义的跨域</h2><ul><li>资源跳转：a链接、重定向、表单提交</li><li>资源嵌入：<code>&lt;link&gt;</code> <code>&lt;script&gt;</code> <code>&lt;img&gt;</code> <code>&lt;iframe&gt;</code>等DOM标签，还有样式中的<code>background:url()</code> <code>@font-face()</code>等文件外链不存在跨域请求的限制</li><li>脚本请求：js发起的ajax请求、dom和js对象的跨域操作  </li></ul><hr><h2 id="同源策略（狭义的）"><a href="#同源策略（狭义的）" class="headerlink" title="同源策略（狭义的）"></a>同源策略（狭义的）</h2><ul><li>同源策略：是浏览器的一种安全策略，同源指的是请求URL地址中的协议、域名和端口都相同，其中之一不相同就是跨域</li><li>同源策略主要是为了保证浏览器的安全性</li><li>同源策略下，浏览器不允许Ajax跨域获取服务器数据</li><li>同源策略限制以下几种行为<ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM和JS对象无法获得</li><li>AJAX 请求不能发送</li></ul></li></ul><hr><h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><h2 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h2><ul><li>原生js实现<pre><code>&lt;script&gt;  // 动态创建script标签 也可以在script标签的src属性中直接指定请求地址 不太灵活  // 动态创建script标签是异步请求  var script = document.createElement(&#39;script&#39;);  script.type = &#39;text/javascript&#39;;  var username = &#39;admin&#39;  // 指定后端返回并执行的回调函数的名称  script.src = &#39;http://www.domain.com/login?username=&#39;+username+&#39;&amp;callback=handerCallback&#39;;  document.head.appendChild(script);  // 回调函数 由服务端响应的内容调用  function handlerCallback(data) {    console.log(data);  }   // 服务端的返回的内容是一个函数调用  handlerCallback({&quot;username&quot;:&quot;admin&quot;,&quot;status&quot;:200})&lt;/script&gt;</code></pre></li><li>jQuery实现<pre><code>$.ajax({  type: &#39;get&#39;,  url: &#39;http://www.domain.com/login&#39;,  dataType: &#39;jsonp&#39;, // 必须指定jsonp格式 只支持get请求  data: {},  jsonp: &#39;cb&#39;, // 默认值为callback &#39;=&#39;前面的值  jsonpCallback: &#39;handlerCallback&#39;, // 自定义回调函数的名字 &#39;=&#39;后面的值  success: function(data) {  },  error: function(err) {  }})</code></pre></li></ul><hr><h2 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h2><ul><li>客户端（发送ajax请求）</li><li>服务端设置相关的头信息（包含源是否允许携带凭证，需要处理options试探性请求，多源不能使用cookie）</li></ul><hr><h2 id="http-proxy代理（配合webpack-webpack-dev-server使用）"><a href="#http-proxy代理（配合webpack-webpack-dev-server使用）" class="headerlink" title="http proxy代理（配合webpack webpack-dev-server使用）"></a>http proxy代理（配合webpack webpack-dev-server使用）</h2><hr><h2 id="nodejs中间件代理跨域"><a href="#nodejs中间件代理跨域" class="headerlink" title="nodejs中间件代理跨域"></a>nodejs中间件代理跨域</h2><hr><h2 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h2><hr><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><ul><li><p>可以解决以下问题</p><ul><li>多窗口之间消息传递</li><li>页面和其打开的新窗口的数据传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul></li><li><p>页面一（<a href="http://www.test1.com/a.html）" target="_blank" rel="noopener">www.test1.com/a.html）</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&#39;iframe&#39;);    iframe.onload = function() {        var data = {            name: &#39;Kobe&#39;        };        // 发送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http://www.test2.com&#39;);    };    // 接受返回的数据    window.onmessage = function(e) {        // e.data的是接收到的信息        console.log(&#39;data from test2 ---&gt; &#39; + e.data);    }&lt;/script&gt;</code></pre></li><li><p>页面二（<a href="http://www.test1.com/b.html）" target="_blank" rel="noopener">www.test1.com/b.html）</a></p><pre><code>&lt;script&gt;// 接收test1的数据window.onmessage = function(e) {    alert(&#39;data from test1 ---&gt; &#39; + e.data);    var data = JSON.parse(e.data);    if (data) {        data.age = 40;        // 处理后再发回test1        window.parent.postMessage(JSON.stringify(data), &#39;http://www.test1.com&#39;);    }}&lt;/script&gt;</code></pre></li></ul><hr><h2 id="WebSocket协议跨域（客户端和服务端实时通信）"><a href="#WebSocket协议跨域（客户端和服务端实时通信）" class="headerlink" title="WebSocket协议跨域（客户端和服务端实时通信）"></a>WebSocket协议跨域（客户端和服务端实时通信）</h2><pre><code>  &lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;  &lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var socket = io(&#39;http://www.test2.com:8080&#39;);    // 连接成功处理    socket.on(&#39;connect&#39;, function() {        // 监听服务端消息        socket.on(&#39;message&#39;, function(msg) {            console.log(&#39;data from server: ---&gt; &#39; + msg);         });        // 监听服务端关闭        socket.on(&#39;disconnect&#39;, function() {             console.log(&#39;Server socket has closed.&#39;);         });    });    document.getElementsByTagName(&#39;input&#39;)[0].onblur = function() {        socket.send(this.value);    };  &lt;/script&gt;</code></pre><hr><h2 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h2><ul><li>应用场景：只能实现同一个主域，不同子域的跨域应用场景</li><li>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域</li><li>父页面（<a href="http://www.test.com/a.html）" target="_blank" rel="noopener">www.test.com/a.html）</a><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://school.test.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    document.domain = &#39;test.com&#39;;    var data = &#39;Kobe&#39;;&lt;/script&gt;</code></pre></li><li>子页面（school.test.com/b.html）<pre><code>&lt;script&gt;  document.domain = &#39;test.com&#39;;  // window.parent ==&gt; b页面的父页面就是a  // 获取父窗口中变量   console.log(&#39;get js data from parent ---&gt; &#39; + window.parent.data);&lt;/script&gt;</code></pre></li></ul><hr><h2 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a>window.name + iframe</h2><ul><li>页面一（<a href="http://www.test1.com/a.html）" target="_blank" rel="noopener">www.test1.com/a.html）</a><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&#39;iframe&#39;);    var count = 0;    iframe.onload = function() {      // 需要把地址重新指向到同源的页面二才可以 这样onload执行两次      if (count === 0) {        iframe.src = &#39;http://www.test1.com/proxy.html&#39;;        count++;        return;      }      console.log(iframe.contentWindow.name); // Kobe    };&lt;/script&gt;</code></pre></li><li>页面二（<a href="http://www.test1.com/proxy.html）：中间代理页，与页面一同域，页面不用写东西" target="_blank" rel="noopener">www.test1.com/proxy.html）：中间代理页，与页面一同域，页面不用写东西</a></li><li>页面三（<a href="http://www.test2.com/b.html）" target="_blank" rel="noopener">www.test2.com/b.html）</a><pre><code>&lt;script&gt;  window.name = &#39;Kobe&#39;;&lt;/script&gt;</code></pre></li></ul><hr><h2 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash + iframe"></a>location.hash + iframe</h2><ul><li><p>页面一（<a href="http://www.test1.com/a.html）" target="_blank" rel="noopener">www.test1.com/a.html）</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#39;iframe&#39;);    setTimeout(function() {      // 向b.html传hash值      // iframe.src = iframe.src + &#39;#name=kobe&#39;;      iframe.src = &#39;http://www.test2.com/b.html#name=kobe&#39;;    }, 1000);    // 开放给同域c.html的回调方法    function callback(res) {      alert(&#39;data from c.html ---&gt; &#39; + res);    }&lt;/script&gt;</code></pre></li><li><p>页面二（<a href="http://www.test2.com/b.html）" target="_blank" rel="noopener">www.test2.com/b.html）</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&#39;iframe&#39;);    // 监听a.html传来的hash值，再传给c.html    window.onhashchange = function () {        iframe.src = iframe.src + location.hash;    };&lt;/script&gt;</code></pre></li><li><p>页面三（<a href="http://www.test1.com/c.html）和页面一同源" target="_blank" rel="noopener">www.test1.com/c.html）和页面一同源</a></p><pre><code>&lt;script&gt;  // 监听b.html传来的hash值  window.onhashchange = function () {      // 再通过操作同域a.html的js回调，将结果传回c      window.parent.parent.callback(&#39;hello: &#39; + location.hash.replace(&#39;#name=&#39;, &#39;&#39;));  };&lt;/script&gt;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跨域（非同源策略请求）&quot;&gt;&lt;a href=&quot;#跨域（非同源策略请求）&quot; class=&quot;headerlink&quot; title=&quot;跨域（非同源策略请求）&quot;&gt;&lt;/a&gt;跨域（非同源策略请求）&lt;/h1&gt;&lt;h2 id=&quot;广义的跨域&quot;&gt;&lt;a href=&quot;#广义的跨域&quot; class
      
    
    </summary>
    
    
      <category term="-跨域" scheme="http://yoursite.com/categories/%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="-跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>jQuery回顾</title>
    <link href="http://yoursite.com/2020/08/17/jQuery/"/>
    <id>http://yoursite.com/2020/08/17/jQuery/</id>
    <published>2020-08-17T09:04:36.000Z</published>
    <updated>2020-08-19T09:04:05.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于jQuery"><a href="#关于jQuery" class="headerlink" title="关于jQuery"></a>关于jQuery</h2><ul><li>是什么：本质上就是一个<code>JavaScript</code>函数库</li><li>使用jQuery的原因<ul><li>DOM实现一个简单的功能需要很多的代码</li><li>DOM中兼容性问题很多</li><li>DOM中代码的容错性很差</li><li>DOM中的<code>window.onload</code>只能有一个</li></ul></li></ul><hr><h2 id="jQuery中的顶级对象"><a href="#jQuery中的顶级对象" class="headerlink" title="jQuery中的顶级对象$"></a>jQuery中的顶级对象<code>$</code></h2><ul><li>DOM中的顶级对象为<code>document</code> 页面中的顶级对象</li><li>BOM中的顶级对象为<code>window</code> 浏览器中的顶级对象</li><li>jQuery中的顶级对象为<code>jQuery</code>或者为<code>$</code></li></ul><hr><h2 id="页面的加载事件"><a href="#页面的加载事件" class="headerlink" title="页面的加载事件"></a>页面的加载事件</h2><ul><li>DOM中的加载事件（只能执行最后一个）<pre><code>window.onload = function() {  console.log(&#39;DOM1&#39;);}window.onload = function() {  console.log(&#39;DOM2&#39;);}// 最后的结果为DOM2</code></pre></li><li>jQuery中的加载事件<ul><li>写法一（页面所有的内容加载完毕后触发，包括标签、图片、文字内容）<pre><code>$(window).load = function() {  console.log(&#39;jQuery1&#39;);}$(window).load = function() {  console.log(&#39;jQuery2&#39;);}// 执行结果为 jQuery1 jQuery2</code></pre></li><li>写法二（页面中基本的标签加载完毕后触发，比写法一速度快一些）<pre><code>$(document).ready = function() {  console.log(&#39;jQuery1&#39;);}$(document).ready = function() {  console.log(&#39;jQuery2&#39;);}// 执行结果为 jQuery1 jQuery2</code></pre></li><li>写法三（页面中基本的标签加载完毕后触发，比写法一速度快一些）<pre><code>$(function() {  console.log(&#39;jQuery1&#39;);})$(function() {  console.log(&#39;jQuery2&#39;);})// 执行结果为 jQuery1 jQuery2</code></pre></li></ul></li></ul><hr><h2 id="jQuery和DOM对象的相互转换"><a href="#jQuery和DOM对象的相互转换" class="headerlink" title="jQuery和DOM对象的相互转换"></a>jQuery和DOM对象的相互转换</h2><ul><li>DOM对象转jQuery对象<pre><code>var btn = document.getElementById(&#39;btn&#39;); // DOM对象$(btn).click(function() {}); // jQuery对象</code></pre></li><li>jQuery对象转DOM对象<pre><code>var btn = $(&#39;#btn&#39;); // jQuery对象btn.get(0); // DOM对象btn[0]; // DOM对象</code></pre></li></ul><hr><h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><ul><li>根据id来选择–&gt;<code>$(&#39;#id的值&#39;)</code> 一个</li><li>根据标签名获取–&gt;<code>$(&#39;标签的名字&#39;)</code> 多个</li><li>根据类样式的名字–&gt;<code>$(&#39;.类样式的名字&#39;)</code> 多个</li><li>层次选择器–&gt;<code>$(&#39;ul&gt;li&#39;)</code></li><li>索引选择器<pre><code>$(&#39;ul&gt;li:eq(4)&#39;); // 获取索引为4的li元素$(&#39;ul&gt;li:gt(4)&#39;); // 获取索引大于4的li元素$(&#39;ul&gt;li:lt(4)&#39;); // 获取索引小于4的li元素</code></pre></li><li>关于获取兄弟元素<pre><code>// 获取当前元素的下一个兄弟元素$(&#39;#box&#39;).next(); // 获取当前元素的后面的所有兄弟元素$(&#39;#box&#39;).nextAll();// 获取当前元素的前一个兄弟元素$(&#39;#box&#39;).prev();// 获取当前元素的前面的所有的兄弟元素$(&#39;#box&#39;).prevAll();// 获取当前元素的所有的兄弟元素$(&#39;#box&#39;).siblings();</code></pre></li></ul><hr><h2 id="jQuery样式操作"><a href="#jQuery样式操作" class="headerlink" title="jQuery样式操作"></a>jQuery样式操作</h2><ul><li><p>添加和移除类样式</p><pre><code>// 添加$(&#39;#btn&#39;).click(function() {  // 添加cls和cls2类样式   // $(&#39;#box&#39;).addClass(&#39;cls&#39;).addClass(&#39;cls2&#39;);  $(&#39;#box&#39;).addClass(&#39;cls cls2&#39;);})// 移除$(&#39;#btn&#39;).click(function() {  // 移除cls  // $(&#39;#box&#39;).removeClass(&#39;cls&#39;)  // 移除所有类样式  $(&#39;#box&#39;).removeClass();})</code></pre></li><li><p>判断是否应用了类样式</p><pre><code>var result = $(&#39;#box&#39;).hasClass(&#39;cls&#39;); // true或false</code></pre></li><li><p>切换元素的类样式方法<code>toggleClass()</code></p></li><li><p>设置和获取坐标</p><pre><code>$(&#39;#box&#39;).offset({  &quot;top&quot;: 200,  &quot;left&quot;: 200})$(&#39;#box&#39;).offset().left;$(&#39;#box&#39;).offset().top;</code></pre></li><li><p>滚动出去的距离</p><pre><code>$(document).scrollLeft(); // 数字类型$(document).scrollTop(); // 数字类型</code></pre></li></ul><hr><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><pre><code>$(&#39;#box&#39;).html(&#39;&lt;p&gt;p标签&lt;/p&gt;&#39;).css(&quot;backgroundColor&quot;,&quot;red&quot;);$(&#39;#btn&#39;).click(function() {}).mouseover(function() {})</code></pre><hr><h2 id="jQuery中的动画"><a href="#jQuery中的动画" class="headerlink" title="jQuery中的动画"></a>jQuery中的动画</h2><ul><li>显示和隐藏<ul><li>数字参数：1000表示1000毫秒</li><li>字符串参数：slow normal fast<pre><code>$(&#39;#btn1&#39;).click(function() {// $(&#39;#box&#39;).hide(1000)；$(&#39;#box&#39;).hide(&#39;slow&#39;);})$(&#39;#btn2&#39;).click(function() {// $(&#39;#box&#39;).show(1000);$(&#39;#box&#39;).show(&#39;normal&#39;);})</code></pre></li></ul></li><li>滑入、滑出和切换<ul><li>数字参数：1000表示1000毫秒</li><li>字符串参数：slow normal fast<pre><code>$(&#39;#btn1&#39;).click(function() {$(&#39;#box&#39;).slideUp();})$(&#39;#btn2&#39;).click(function() {$(&#39;#box&#39;).slideDown();})$(&#39;#btn3&#39;).click(function() {$(&#39;#box&#39;).slideToggle();})</code></pre></li></ul></li><li>淡入、淡出和切换<ul><li>数字参数：1000表示1000毫秒</li><li>字符串参数：slow normal fast<pre><code>$(&#39;#btn1&#39;).click(function() {$(&#39;#box&#39;).fadeIn();})$(&#39;#btn2&#39;).click(function() {$(&#39;#box&#39;).fadeOut();})$(&#39;#btn3&#39;).click(function() {$(&#39;#box&#39;).fadeToggle();})</code></pre></li></ul></li><li>透明度变化<ul><li>参数一：时间</li><li>参数二：透明度<pre><code>$(&#39;#btn&#39;).click(function() {$(&#39;#box&#39;).fadeTo(1000, 0.3);})</code></pre></li></ul></li><li><code>animate</code>方法<ul><li>参数一：对象</li><li>参数二：时间</li><li>参数三：匿名函数<pre><code>$(&#39;#btn&#39;).click(function() {$(&#39;#box&#39;).animate({  &quot;width&quot;: &quot;300px&quot;,  &quot;height&quot;: &quot;300px&quot;}, 1000, function() {  $(&#39;#box&#39;).animate({    &quot;width&quot;: &quot;100px&quot;,    &quot;height&quot;: &quot;100px&quot;  }, 1000)})})</code></pre></li></ul></li><li><code>stop()</code>停止动画的方法</li></ul><hr><h2 id="jQuery动态创建元素"><a href="#jQuery动态创建元素" class="headerlink" title="jQuery动态创建元素"></a>jQuery动态创建元素</h2><ul><li><p><code>$(&#39;标签的代码&#39;)</code></p><pre><code>var a = $(&#39;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#39;);$(&#39;#box&#39;).append(a); // 追加到某个元素后面$(&#39;#box&#39;).prepend(a); // 追加到某个元素前面$(&#39;#box&#39;).after(a); // 把元素追加到当前元素的后面（兄弟元素）$(&#39;#box&#39;).before(a); // 把元素追加到当前元素的前面（兄弟元素）a.appendTo($(&#39;#box&#39;)); // 追加到box中</code></pre></li><li><p><code>对象.html(&#39;标签的代码&#39;)</code></p><pre><code>$(&#39;#box&#39;).html(&#39;&lt;p&gt;p标签&lt;/p&gt;&#39;);</code></pre></li><li><p>移除和克隆内容</p><pre><code>$(&#39;#box&#39;).html(); // 移除box中的元素$(&#39;#box&#39;).empty(); // 移除box中的元素$(&#39;#box&#39;).remove(); // 移除元素自身var box = $(&#39;#box&#39;).clone(); // 克隆box元素</code></pre></li></ul><hr><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><ul><li><p>获取属性的值<br><code>$(&#39;#box&#39;).attr(&#39;title&#39;);</code>href</p></li><li><p>设置属性的值</p><pre><code>$(&#39;#box&#39;).attr(&#39;name&#39;,&#39;http://www.baidu.com&#39;);$(&#39;#div :checkbox&#39;).prop(&#39;checked&#39;, true);</code></pre></li></ul><hr><h2 id="事件绑定和解绑"><a href="#事件绑定和解绑" class="headerlink" title="事件绑定和解绑"></a>事件绑定和解绑</h2><ul><li><code>bind() unbind()</code> 不推荐<pre><code>// 绑定单个事件$(&#39;#btn&#39;).bind(&#39;click&#39;, function() {})// 解绑$(&#39;#btn&#39;).unbind(&#39;click&#39;);// 绑定多个事件$(&#39;#btn&#39;).click().mouseover().mouseout();$(&#39;#btn&#39;).bind({  &quot;click&quot;: function() {}}, {  &quot;mouseover&quot;: function() {}},{  &quot;mouseout&quot;: function() {} })</code></pre></li><li><code>delegate() undelegate()</code> 不推荐<pre><code>// 为box中的p标签绑定点击事件$(&#39;#box&#39;).delegate(&#39;p&#39;,&#39;click&#39;,function() {})// 解绑$(&#39;#box&#39;).undelegate(&#39;p&#39;,&#39;click&#39;);</code></pre></li><li><code>on() off()</code><pre><code>// 给按钮绑定点击事件$(&#39;#btn&#39;).on(&#39;click&#39;, function() {})// 解绑$(&#39;#btn&#39;).off(&#39;click&#39;);// 给box中的p标签绑定点击事件$(&#39;#box&#39;).on(&#39;click&#39;,&#39;p&#39;,function() {})</code></pre></li></ul><hr><h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><ul><li>方式一<pre><code>$(&#39;#btn&#39;).click()</code></pre></li><li>方式二<pre><code>$(&#39;#btn&#39;).trigger(&#39;click&#39;);</code></pre></li><li>方式三<pre><code>$(&#39;#btn&#39;).triggerHandler(&#39;click&#39;);</code></pre></li></ul><hr><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><pre><code>$(&#39;#box&#39;).on(&#39;click&#39;,&#39;input&#39;,function(event) {  /**  * event.delegateTarget--&gt;指向的是box  * event.currentTarget--&gt;指向的是input  * event.target--&gt;指向的是input  */ })</code></pre><hr><h2 id="事件冒泡及取消事件冒泡"><a href="#事件冒泡及取消事件冒泡" class="headerlink" title="事件冒泡及取消事件冒泡"></a>事件冒泡及取消事件冒泡</h2><pre><code>// box1中有box2，box2中有box3$(&#39;#box1&#39;).click(function() {  console.log(&#39;box1&#39;);})$(&#39;#box2&#39;).click(function() {  console.log(&#39;box2&#39;);})$(&#39;#box3&#39;).click(function() {  console.log(&#39;box3&#39;);  return false; // 取消事件冒泡})// 点击box3 结果打印box3 box2 box1（事件冒泡）</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于jQuery&quot;&gt;&lt;a href=&quot;#关于jQuery&quot; class=&quot;headerlink&quot; title=&quot;关于jQuery&quot;&gt;&lt;/a&gt;关于jQuery&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;是什么：本质上就是一个&lt;code&gt;JavaScript&lt;/code&gt;函数库&lt;/l
      
    
    </summary>
    
    
      <category term="-jQuery" scheme="http://yoursite.com/categories/jQuery/"/>
    
    
      <category term="-jQuery回顾" scheme="http://yoursite.com/tags/jQuery%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2020/08/15/Ajax/"/>
    <id>http://yoursite.com/2020/08/15/Ajax/</id>
    <published>2020-08-15T10:55:44.000Z</published>
    <updated>2020-08-21T03:56:52.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax请求"><a href="#Ajax请求" class="headerlink" title="Ajax请求"></a>Ajax请求</h2><ul><li><p>创建对象</p><pre><code>var xhr = new XMLHttpRequest(); // 标准浏览器var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); // IE老版本（IE6）</code></pre></li><li><p>准备发送</p><ul><li>参数一：请求方式（get/post）</li><li>参数二：请求地址</li><li>参数三：同步或异步标志位 true-&gt;异步 默认为true </li><li>请求参数：get请求必须拼接在地址上并且要经过编码处理<pre><code>var param = &#39;username=admin&#39;;// getxhr.open(&#39;get&#39;, &#39;请求地址?&#39;+encodeURI(param), true);</code></pre></li></ul><p>// post<br>xhr.open(‘get’, ‘请求地址’, true);<br>```</p></li><li><p>执行发送动作</p><pre><code>// getxhr.send(null); // get请求需要null参数// postxhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); // 设置请求头xhr.send(param); // post请求参数在send中传递 不需要转码 但要设置请求头</code></pre></li><li><p>指定回调函数</p><ul><li><code>xhr.readyState = 0</code> 表示xhr对象初始化完成 </li><li><code>xhr.readyState = 1</code> 表示已经发送了请求 </li><li><code>xhr.readyState = 2</code> 表示浏览器已经收到服务器响应数据，但未解析 </li><li><code>xhr.readyState = 3</code> 数据解析 </li><li><code>xhr.readyState = 4</code> 数据解析完成，可以使用 <pre><code>xhr.onreadystatechange = function() {    if (xhr.readyState == 4) {      if (xhr.status == 200) {}  }}</code></pre></li></ul></li></ul><hr><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul><li><code>json</code>数据和普通<code>js</code>对象的区别<ul><li><code>json</code>数据没有变量</li><li><code>json</code>形式的数据结尾没有分号</li><li><code>json</code>数据中的键必须用双引号包住</li></ul></li></ul><hr><h2 id="Ajax函数封装"><a href="#Ajax函数封装" class="headerlink" title="Ajax函数封装"></a>Ajax函数封装</h2><pre><code>function ajax(url,type,param,dataType,callback) {    // 处理兼容性    var xhr = null;    if (window.XMLHttpRequest) {        xhr = new XMLHttpRequest();    } else {        xhr = new ActiveXObject(&quot;Microsoft-XMLHTTP&quot;);    }    if (type == &#39;get&#39;) {        url += &#39;?&#39; + encodeURI(param);    }    var data = null;    if (type == &#39;post&#39;) {        data = param;        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)    }    xhr.open(type, url, true);    xhr.send(null);    xhr.onreadystatechange = function() {        if (xhr.readyState == 4) {            if (xhr.status == 200) {                var data = xhr.responseText;                if (dataType == &#39;json&#39;) {                    data = JSON.parse(data);                }                callback(data);            }        }     }}</code></pre><hr><h2 id="jQuery中的Ajax请求"><a href="#jQuery中的Ajax请求" class="headerlink" title="jQuery中的Ajax请求"></a>jQuery中的Ajax请求</h2><pre><code>$.ajax({    type: &#39;get&#39;,    // url: &#39;localhost?name=Kobe&#39;,    url: &#39;localhost&#39;,    data: {name: &#39;Kobe&#39;},    dataType: &#39;json&#39;,    success: function(data) {      },    error: function() {    }})</code></pre><hr><h2 id="原生模仿jQuery封装ajax"><a href="#原生模仿jQuery封装ajax" class="headerlink" title="原生模仿jQuery封装ajax"></a>原生模仿jQuery封装ajax</h2><pre><code>function ajax(obj) {    var defaults = {        type: &#39;get&#39;,        data: {},        url: &#39;#&#39;,        dataType: &#39;text&#39;,        async: true,        success: function(data) {            console.log(data);        }    }    for (var key in obj) {        defaults[key] = obj[key];    }    var xhr = null;    if (window.XMLHttpRequest) {        xhr = new XMLHttpRequest();    } else {        xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);    }    var param = &#39;&#39;;    for (var key in obj.data) {        param += key + &#39;=&#39; + obj.data[key] + &#39;&amp;&#39;;    }    // 去除最后一个多余的&amp;    param = param.substring(0, param.length - 1);    if (defaults.type == &#39;get&#39;) {        // get请求设置中文转码        defaults.url += &#39;?&#39; + encodeURI(param);    }    xhr.open(defaults.type,defaults.url,defaults.async);    var dat = null;    if (defaults.type == &#39;post&#39;) {        dat = param;         // post请求设置请求头        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);    }    xhr.send(dat);    // 同步    if (!defaults.async) {        if (defaults.dataType == &#39;json&#39;) {            return JSON.parse(xhr.responseText);            }        return xhr.responseText;    }    // 异步    xhr.onreadystatechange = function() {        if (xhr.readState == 4) {            if (xhr.status == 200) {                var data = xhr.responseText;                if (defaults.dataType == &#39;json&#39;) {                    data = JSON.parse(data);                }                defaults.success(data);            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ajax请求&quot;&gt;&lt;a href=&quot;#Ajax请求&quot; class=&quot;headerlink&quot; title=&quot;Ajax请求&quot;&gt;&lt;/a&gt;Ajax请求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequ
      
    
    </summary>
    
    
      <category term="-Ajax" scheme="http://yoursite.com/categories/Ajax/"/>
    
    
      <category term="-Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级回顾</title>
    <link href="http://yoursite.com/2020/08/04/JavaScript-Review-Heigh/"/>
    <id>http://yoursite.com/2020/08/04/JavaScript-Review-Heigh/</id>
    <published>2020-08-04T07:05:41.000Z</published>
    <updated>2020-08-14T02:26:38.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="构造函数的原型（通过原型创建的方法，所有构造函数的实例对象都可以访问）"><a href="#构造函数的原型（通过原型创建的方法，所有构造函数的实例对象都可以访问）" class="headerlink" title="构造函数的原型（通过原型创建的方法，所有构造函数的实例对象都可以访问）"></a>构造函数的原型（通过原型创建的方法，所有构造函数的实例对象都可以访问）</h2><pre><code>function Person(name, age) {    this.name = name;    this.age = age;}Person.prototype.getName = function() {    return this.name;}var person = new Person(&#39;Kobe&#39;, 40);console.log(person.getName()) // Kobe</code></pre><h2 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h2><pre><code>function Person(name, age) {    this.name = name;    this.age = age;    this.getName = function() {        return this.name;    }}var person = new Person(&#39;Kobe&#39;, 40);console.log(person.__proto__ === Person.prototype); // true</code></pre><ul><li>当调用对象的属性或方法时，先去找对象本身的属性或方法，如果对象没有该属性或方法，此时则调用原型中的属性或方法</li><li>当设置对象的属性时，不会查询原型链，如果对象没有该属性，直接添加该属性</li></ul><hr><h2 id="自调用函数（解决命名冲突，连续写多个自调用函数时要加分号）"><a href="#自调用函数（解决命名冲突，连续写多个自调用函数时要加分号）" class="headerlink" title="自调用函数（解决命名冲突，连续写多个自调用函数时要加分号）"></a>自调用函数（解决命名冲突，连续写多个自调用函数时要加分号）</h2><pre><code>;(function() {    // 局部作用域 外部访问不到    var src = &#39;abc&#39;;    window.src = src; // 外部能访问到})()</code></pre><ul><li>自调用函数的参数<pre><code>;(function(w, u) {    // 传入window让变量名可以被压缩    // 老版浏览器传入undefined防止值被改变})(window, undefined)</code></pre></li></ul><hr><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><ul><li><code>bind</code><pre><code>var src = &#39;Kobe&#39;;function fun1() {    console.log(this.src)}fun1(); // Kobevar o = {src: &#39;James&#39;}var fun2 = fun1.bind(o); // bind第一个参数改变this指向fun2(); // James</code></pre></li></ul><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="对象之间的拷贝"><a href="#对象之间的拷贝" class="headerlink" title="对象之间的拷贝"></a>对象之间的拷贝</h2><pre><code>function extend(parent, child) {    for (var key in parent) {        if (child[key]) {            continue;        }        child[key] = parent[key];    }}</code></pre><hr><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><pre><code>function Person() {    this.age = 40;}function Student() {    this.name = &#39;Kobe&#39;}Student.prototype = new Person();Student.prototype.constructor = Student;</code></pre><hr><h2 id="bind-call-apply"><a href="#bind-call-apply" class="headerlink" title="bind call apply"></a><code>bind</code> <code>call</code> <code>apply</code></h2><ul><li><code>bind</code>改变<code>this</code>的指向，复制一个新的函数（不调用函数）<pre><code>function sum(x, y) {    console.log(this);    return x + y;}sum(1,3); // this-&gt;window 相当于window.sum(1,3);var obj = {name: &#39;Kobe&#39;};var fun = sum.bind(obj, 1, 3);fun(); // this-&gt;obj// 应用var o = {    name: &#39;James&#39;,    fn: function() {        setInterval(function() {            console.log(this.name); // 没调用bind前this指向window,调用bind后指向o        }.bind(this), 1000)    }}</code></pre></li><li><code>call</code>改变<code>this</code>的指向，直接调用函数，返回值就是函数的返回值<pre><code>function sum(x, y) {    console.log(this);    return x + y;}var obj = {name: &#39;Kobe&#39;};sum.call(obj, 1, 3); // this-&gt;obj</code></pre></li><li><code>apply</code>改变<code>this</code>的指向，直接调用函数，返回值就是函数的返回值，第二个参数是一个数组，把数组的每一项展开传给函数<pre><code>var arr = [2, 4, 6, 8, 0, 1];console.log(Math.max(arr)); // NaN// 应用console.log(Math.max.apply(Math, arr)); // 8console.log.apply(console, arr); // 2 4 6 8 0 1</code></pre></li></ul><hr><h2 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h2><pre><code>function Person(name, age) {    this.name = name;    this.age = age;}function Student(name,age,score) {    Person.call(this, name, age); // 借用构造函数以及call    this.score = score;}</code></pre><hr><h2 id="组合继承（原型继承-组合继承）"><a href="#组合继承（原型继承-组合继承）" class="headerlink" title="组合继承（原型继承+组合继承）"></a>组合继承（原型继承+组合继承）</h2><pre><code>function Person(name, age) {    this.name = name;    this.age = age;}Person.prototype.sayHi = function () {    console.log(&#39;hello&#39; + this.name);}function Student(name, age, score) {    Person.call(this, name, age); // 借用构造函数    this.score = score;}Student.prototype = new Person(); // 让子类型继承父类型的方法 这一步可以给子类型添加独有的方法而不会影响父类型Student.prototype.constructor = Student;</code></pre><hr><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h2><ul><li><p>函数声明</p><pre><code>function fun() {    console.log(&#39;hello&#39;);}</code></pre></li><li><p>函数表达式</p><pre><code>var fun = function() {    console.log(&#39;hello&#39;);}</code></pre></li><li><p><code>new Function()</code> 代码解析较慢</p><pre><code>var fun = new Function(&#39;a&#39;,&#39;b&#39;,console.log(a + b)&#39;)</code></pre></li><li><p>函数声明和表达式的区别</p><pre><code>fun1();   // fun1function fun1() {    console.log(&#39;fun1&#39;);}fun2(); // 报错var fun2 = function() {    console.log(&#39;fun2&#39;);}// 以上分析（预解析过程）function fun1() {    console.log(&#39;fun1&#39;);}var fun2;fun1(); // fun1fun2(); // 此时不是函数fun2 = function() {    console.log(&#39;fun2&#39;);}</code></pre></li></ul><hr><h2 id="函数调用方式以及内部this指向"><a href="#函数调用方式以及内部this指向" class="headerlink" title="函数调用方式以及内部this指向"></a>函数调用方式以及内部<code>this</code>指向</h2><ul><li>普通函数调用<pre><code>function fun() {    console.log(this); // window}fun();</code></pre></li><li>作为方法调用<pre><code>var obj = {    fun: function() {        console.log(this); // obj    }}obj.fun();</code></pre></li><li>作为构造函数调用 内部<code>this</code>指向由该构造函数创建的对象</li><li>作为事件的处理函数 <code>this</code>指向事件源</li><li>作为定时器的参数<pre><code>setTimeout(function() {    console.log(this); // window}, 1000)</code></pre></li></ul><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul><li>概念：闭包是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域，通常用和其相应的函数来指代这些作用域（可以独立访问数据的函数），个人理解就是一个作用域中访问到另一个作用域中的变量或函数的一种现象</li><li>闭包的好处：延展了作用域的范围</li></ul><hr><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><pre><code>var obj1 = {    name: &#39;Kobe&#39;,    age: 40,    friend: {        name: &#39;James&#39;,        age: 44    }}var obj2 = {}for (var key in obj1) {    obj2[key] = obj1[key];  // 复杂类型复制的地址}// 浅拷贝 修改ojb1中的name、age不会影响obj2，但修改obj1中friend中的name、age会影响obj2中friend</code></pre><hr><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><pre><code>var obj1 = {    name: &#39;Kobe&#39;,    age: 40,    friend: {      name: &#39;James&#39;,      age: 44    },    hobbies: [&#39;看电影&#39;, &#39;打篮球&#39;]};// obj1拷贝给obj2function deepCopy(obj1, obj2) {    for (var key in obj1) {      var item = obj1[key];      if (item instanceof Array) {        obj2[key] = [];        deepCopy(item, obj2[key])      } else if (item instanceof Object) {        obj2[key] = {};        deepCopy(item, obj2[key])      } else {        obj2[key] = item;      }    }}var obj2 = {}deepCopy(obj1, obj2);obj1.friend.name = &#39;YaoMing&#39;;console.log(obj2.friend.name); // James</code></pre><hr><h1 id="正则表达式（匹配规律规则的表达式）"><a href="#正则表达式（匹配规律规则的表达式）" class="headerlink" title="正则表达式（匹配规律规则的表达式）"></a>正则表达式（匹配规律规则的表达式）</h1><h2 id="内置对象RegExp"><a href="#内置对象RegExp" class="headerlink" title="内置对象RegExp"></a>内置对象<code>RegExp</code></h2><pre><code>var regularExpression = new RegExp(&#39;ab[a-z]&#39;, &#39;i&#39;);var str = &#39;aBc&#39;;console.log(regularExpression.test(str)); // true</code></pre><ul><li>第一个参数 模式pattern</li><li>第二个参数 flag i-&gt;忽略大小写 g-&gt;全局匹配</li></ul><hr><h2 id="简单写法"><a href="#简单写法" class="headerlink" title="简单写法"></a>简单写法</h2><pre><code>var regularExpression = /ab[a-z]/i;var str = &#39;aBc&#39;;console.log(regularExpression.test(str)); // true</code></pre><hr><h2 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h2><ul><li><p><code>RegExp</code>对象的方法</p><ul><li><code>test()</code><pre><code>var regExp = /ab[a-z]/i;var str = &#39;aBc&#39;;console.log(regExp.test(str)); // true</code></pre></li><li><code>exec()</code>无论调用多少次只返回一个匹配到的结果，返回所有结果就需要全局匹配并多次调用<pre><code>var str = &#39;Kobe:44,James: 40&#39;;var regExp = /\d+/g;do {    var result = regExp.exec(str); // 数组    if (result != null) {        console.log(result[0])    }} while(result != null)</code></pre></li></ul></li><li><p><code>String</code>对象的方法</p><ul><li><p><code>split()</code></p></li><li><p><code>match()</code></p><pre><code>var str = &#39;Kobe:44,James: 40&#39;;var regExp = /\d+/g; // 需要全局匹配console.log(str.match(regExp)); // 数组// 分组提取var str = &#39;2013-4-3&#39;;var regExp = /(\d{4})-(\d{1,2})-(\d{1,2})/; // 分组提取 str.match(regExp);console.log(RegExp.$1); // 2013console.log(RegExp.$2); // 4console.log(RegExp.$3); // 3</code></pre></li><li><p><code>replace()</code></p><pre><code>var str = &#39; aaa   dd dfsafa  d  &#39;;// 去掉空格str.replace(/\s/g, &#39;&#39;);</code></pre></li><li><p><code>search()</code></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;h2 id=&quot;构造函数的原型（通过原型创建的方法，所有构造函数的实例对象都可以访问）&quot;&gt;&lt;a href=&quot;#构造函数的原型（通过
      
    
    </summary>
    
    
      <category term="-JavaScript回顾" scheme="http://yoursite.com/categories/JavaScript%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="-JavaScript回顾" scheme="http://yoursite.com/tags/JavaScript%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>DOM和BOM</title>
    <link href="http://yoursite.com/2020/07/31/JavaScript-Review-DOM-BOM/"/>
    <id>http://yoursite.com/2020/07/31/JavaScript-Review-DOM-BOM/</id>
    <published>2020-07-31T02:14:32.000Z</published>
    <updated>2020-08-03T02:28:34.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取页面元素"><a href="#获取页面元素" class="headerlink" title="获取页面元素"></a>获取页面元素</h1><ul><li>根据id获取（页面没有此id返回none）<code>document.getElementById(&#39;id&#39;)</code></li><li>根据标签名获取<code>document.getElementsByTagName(&#39;div&#39;)</code></li><li>根据标签的name属性获取<code>document.getElementsByName(&#39;name&#39;)</code> 基本不使用</li><li>根据class属性获取<code>document.getElementsByClassName(&#39;main&#39;)</code></li><li>根据选择器获取<code>document.querySelector(&#39;#id&#39;)</code> -&gt; 只能获取到一个 <code>document.querySelectorAll(&#39;div.main&#39;)</code> -&gt; 获取所有的元素</li></ul><hr><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><ul><li>on+事件名称（只有事件冒泡，不可以注册多次事件）<pre><code>btn.onclick = function() {}</code></pre></li><li><code>addEventListener</code>事件监听器（可以注册多次事件，具有浏览器兼容性问题）<pre><code>btn.addEventListener(&#39;click&#39;, function() {})</code></pre></li><li><code>attachEvent</code>事件监听器（只有事件冒泡，IE老版本）<pre><code>btn.attachEvent(&#39;onclick&#39;, function() {})</code></pre></li></ul><hr><h2 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h2><ul><li>通过<code>btn.onclick = null</code></li><li><code>btn.removeEventListener(&#39;click&#39;, fun)</code></li><li><code>btn.detachEvent(&#39;onclick&#39;, fun)</code></li></ul><hr><h2 id="事件的三个阶段"><a href="#事件的三个阶段" class="headerlink" title="事件的三个阶段"></a>事件的三个阶段</h2><ul><li>第一个阶段：事件捕获阶段（从最外层开始） <code>addEventListener()</code>第三参数为true</li><li>第二个阶段：执行当前点击的元素</li><li>第三个阶段：事件冒泡阶段（与捕获相反） <code>addEventListener()</code>第三参数为false</li></ul><hr><h2 id="事件委托（原理为事件冒泡）"><a href="#事件委托（原理为事件冒泡）" class="headerlink" title="事件委托（原理为事件冒泡）"></a>事件委托（原理为事件冒泡）</h2><pre><code>&lt;ul id=&quot;ul&quot;&gt;  &lt;li&gt;三国演义&lt;/li&gt;  &lt;li&gt;红楼梦&lt;/li&gt;  &lt;li&gt;水浒传&lt;/li&gt;  &lt;li&gt;西游记&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  var ul = document.getElementById(&#39;ul&#39;);  ul.addEventListener(&#39;click&#39;, function (e) {    // e 为事件参数（事件对象）系统调用 老版本中通过window.event获取    // 处理浏览器兼容    e = e || window.event;    e.target.style.backgroundColor = &#39;red&#39;;  })&lt;/script&gt;</code></pre><ul><li>事件对象（e）<ul><li><code>e.eventPhase</code> 事件的阶段：1-&gt;捕获阶段 2-&gt;目标阶段 3-&gt;冒泡阶段</li><li><code>e.target</code> 事件源 具有兼容性问题（e.target = e.target || e.srcElement）</li><li><code>e.currentTarget</code> 事件处理函数所属的对象相当于this</li><li><code>e.type</code> 事件名称</li><li><code>e.clientX/e.clientY</code> 相对于浏览器可视区域坐标</li><li><code>e.pageX/e.pageY</code> 相对于当前页面的位置</li></ul></li></ul><hr><h1 id="阻止默认行为执行和事件冒泡"><a href="#阻止默认行为执行和事件冒泡" class="headerlink" title="阻止默认行为执行和事件冒泡"></a>阻止默认行为执行和事件冒泡</h1><h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><ul><li><p>事件返回值设置为false</p><pre><code>&lt;a id=&quot;link&quot; href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;var link = document.getElementById(&#39;link&#39;);link.onclick = function() {  alert(&#39;跳转&#39;);  return false;   // 取消超链接默认跳转行为  }</code></pre></li><li><p>使用事件对象e</p><pre><code>// DOM标准方式e.preventDefault();// IE老版本 非标准方式e.returnValue = false;</code></pre></li></ul><hr><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><ul><li>使用事件对象<pre><code>// DOM标准方式e.stopPropagation();// IE老版本 非标准方式e.cancelBabble = true;</code></pre></li></ul><hr><h1 id="innerHTML-innerText-和-textContent"><a href="#innerHTML-innerText-和-textContent" class="headerlink" title="innerHTML  innerText 和 textContent"></a><code>innerHTML</code>  <code>innerText</code> 和 <code>textContent</code></h1><ul><li><code>innerHTML</code> 获取内容的时候，如果内容中有标签，会把标签获取到</li><li><code>innerText</code> 获取内容的时候，如果内容中有标签，会把内容过滤掉 旧版IE只支持 </li><li><code>textContent</code> 获取内容的时候，如果内容中有标签，会把内容过滤掉 旧版的火狐只支持</li><li>兼容性处理<pre><code>  function getInnerText(element) {      // 具有该属性类型为string 否则为undefined      if (typeof element.innerText == &#39;string&#39;) {      return element.innerText;      } else {      return element.textContent;      }  }</code></pre></li></ul><hr><h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><ul><li>获取父节点 <code>box.parentNode</code> 只有一个  </li><li>获取所有的子节点 <code>box.childNodes</code> </li><li>获取所有的子元素 <code>box.children</code></li><li>获取第一子节点 <code>box.firstChild</code></li><li>获取最后一个子节点 <code>lastChild</code></li><li>获取第一个子元素（具有兼容性问题） <code>firstElementChild</code></li><li>获取最后一个子元素（具有兼容性问题）  <code>lastElementChild</code></li><li>获取下一个兄弟节点 <code>box.nextSibling</code></li><li>获取上一个兄弟节点 <code>box.previousSibling</code></li><li>获取下一个兄弟元素（具有兼容性问题）  <code>box.nextElementSibling</code></li><li>获取上一个兄弟元素（具有兼容性问题）  <code>box.previousElementSibling</code></li></ul><hr><h1 id="动态创建元素"><a href="#动态创建元素" class="headerlink" title="动态创建元素"></a>动态创建元素</h1><ul><li><code>document.write()</code> 会覆盖页面之前的内容</li><li><code>element.innerHTML</code></li><li><code>document.createElement()</code> 创建一个元素对象</li><li><code>box.appendChild()</code> 在box中追加子元素</li><li><code>insertBefore()</code> 把元素插入到指定位置</li><li><code>replaceChild()</code> 把当前元素的标签进行替换</li></ul><hr><h1 id="offset-client-scroll三大家"><a href="#offset-client-scroll三大家" class="headerlink" title="offset client scroll三大家"></a><code>offset</code> <code>client</code> <code>scroll</code>三大家</h1><ul><li><code>offset</code> 偏移量<ul><li><code>box.offsetParent</code> 获取距离box最近的定位父元素 无定位，则父元素是body</li><li><code>box.offsetLeft</code> 获取box横坐标 是距离<code>offsetParent</code>的横向偏移距离</li><li><code>box.offsetTop</code> 获取box纵坐标 是距离<code>offsetParent</code>的纵向偏移距离</li><li><code>box.offsetWidth</code> 获取box宽度 包括边距和边框</li><li><code>box.offsetHeight</code> 获取box高度 包括边距和padding</li></ul></li><li><code>client</code> <ul><li><code>box.clientLeft</code> 不是元素坐标 对应border-left的宽度</li><li><code>box.clientTop</code> 不是元素坐标 对应border-top的宽度</li><li><code>box.clientWidth</code> 包括padding 不包括边框</li><li><code>box.clientHeight</code> 包括padding 不包括边框</li></ul></li><li><code>scroll</code><ul><li><code>box.scrollLeft</code> 滚动条滚动出去的距离</li><li><code>box.scrollTop</code> 滚动条滚动出去的距离</li><li><code>box.scrollWidth</code> 内容的大小 包括padding和未显示的内容</li><li><code>box.scrollHeight</code> 内容的大小 包括padding和未显示的内容</li><li><code>box.onscroll</code> 拖动滚动条时触发该事件</li></ul></li></ul><hr><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="常用对话框（基本不会使用）"><a href="#常用对话框（基本不会使用）" class="headerlink" title="常用对话框（基本不会使用）"></a>常用对话框（基本不会使用）</h2><ul><li><code>alert(&#39;弹出内容&#39;)</code></li><li><code>prompt(&#39;提示内容&#39;,&#39;默认值&#39;)</code> 返回值为输入的值</li><li><code>confirm(&#39;提示内容&#39;)</code> 返回值为布尔值</li></ul><hr><h2 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h2><ul><li><code>window.onload</code> 页面加载完成后执行</li><li><code>window.onunload</code> 页面卸载时执行（所有对话框不能使用）</li></ul><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul><li><code>setTimeout()</code> 隔一段时间执行，并且只会执行一次<pre><code>var timeId;btn1.addEventListener(&#39;click&#39;, function () {  // 开启定时器  timeId = setTimeout(function () {  }, 1000);})btn2.addEventListener(&#39;click&#39;, function() {  // 取消定时器  clearTimeout(timeId);})</code></pre></li><li><code>setInterval()</code> 隔一段时间执行，并且会重复执行<pre><code>var timeId;btn1.addEventListener(&#39;click&#39;, function () {  // 开启定时器  timeId = setInterval(function () {  }, 1000);})btn2.addEventListener(&#39;click&#39;, function() {  // 取消定时器  clearInterval(timeId);})</code></pre></li></ul><hr><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a><code>location</code>对象</h2><ul><li><code>location.href</code> 让页面跳转到指定位置 记录历史</li><li><code>location.assign()</code> 委派 让页面跳转到指定位置 记录历史</li><li><code>location.replace()</code> 替换 不记录历史</li><li><code>location.reload()</code> 重新加载页面 参数为true会强制从服务器获取页面 参数为false，浏览器有缓存，直接从缓存获取页面</li><li><code>window.history</code> <pre><code>history.back() // 后退history.forward() // 前进history.go(1) // 前进history.go(-1) // 后退</code></pre></li><li>URL 统一资源定位符（scheme://host:port/path?query#fragment）<ul><li>scheme 通信协议 常用：http ftp mailto</li><li>host 主机 服务器域名系统主机名或IP地址</li><li>port 端口号 省略使用默认端口</li><li>path 路径</li><li>query 查询</li><li>fragment 信息片段 字符串，锚点</li></ul></li></ul><hr><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><ul><li><code>navigator.userAgent</code> 当前使用的浏览器、操作系统信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取页面元素&quot;&gt;&lt;a href=&quot;#获取页面元素&quot; class=&quot;headerlink&quot; title=&quot;获取页面元素&quot;&gt;&lt;/a&gt;获取页面元素&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;根据id获取（页面没有此id返回none）&lt;code&gt;document.getElementBy
      
    
    </summary>
    
    
      <category term="-JavaScript回顾" scheme="http://yoursite.com/categories/JavaScript%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="-JavaScript回顾" scheme="http://yoursite.com/tags/JavaScript%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="http://yoursite.com/2020/07/28/JavaScript-Review-Basics/"/>
    <id>http://yoursite.com/2020/07/28/JavaScript-Review-Basics/</id>
    <published>2020-07-28T07:21:19.000Z</published>
    <updated>2020-08-07T03:41:44.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域（变量或者函数可以起作用的访问范围）"><a href="#作用域（变量或者函数可以起作用的访问范围）" class="headerlink" title="作用域（变量或者函数可以起作用的访问范围）"></a>作用域（变量或者函数可以起作用的访问范围）</h1><ul><li>全局作用域：在<code>script</code>标签中或者一个独立的<code>js</code>文件中，全局变量在任何位置都可以访问<pre><code>var num = 1;  // 全局变量function fun() {  str = &#39;abc&#39;;  // 全局变量 不推荐 }</code></pre></li><li>局部作用域：任何函数的内部都有一个局部作用域，在局部作用域中定义的变量为局部变量，只有在定义变量的函数中可以访问<pre><code>function fun() {  var num = 1;  // 局部变量 }console.log(num); // num is not defined</code></pre></li><li>块级作用域：ES6之前没有块级作用域<pre><code>// 代码块{  var num = 1;}console.log(num);  // 1 可以访问到</code></pre></li></ul><hr><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><pre><code>var num = 1;  // 全局作用域 --0级作用域链function fun1() {  var num = 2;  // fun1局部作用域 --1级作用域链  function fun2() {    // fun2局部作用域 --2级作用域链    console.log(num)    }  fun2()}fun1()  // 变量查找顺序 2级作用域链-&gt;1级作用域链-&gt;0级作用域链</code></pre><hr><h1 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h1><ul><li><p>在没有出现<code>let</code> <code>const</code>之前，会出现一些奇怪的问题</p><pre><code>// 问题一console.log(num); // undefinedvar num = 1;// 问题二fun();   // hellofunction fun() {  console.log(&#39;hello&#39;)}</code></pre></li><li><p>预解析过程（当预解析过程中函数和变量名字相同，函数优先）</p><ul><li><p>变量提升：把变量的声明提升到当前作用域的最上面，不包括变量的赋值</p><pre><code>console.log(num); // undefinedvar num = 1;// 上述代码的预解析var num;console.log(num);num = 5;</code></pre></li><li><p>函数提升：把函数的声明提升到当前作用域的最上面，不包括函数的调用，现代浏览器中，<code>if</code>语句中的函数不会提升，在老的IE中会提升</p><pre><code>fun();   // hellofunction fun() {  console.log(&#39;hello&#39;)}// 上述代码的预解析function fun() {  console.log(&#39;hello&#39;)} fun();// 注意function fn() {  var a = b = c = 9;  // 上述代码等价于下面的代码  var a = 9,  // 局部变量  b = 9,  // 全局变量  c = 9;  // 全局变量}</code></pre></li></ul></li></ul><hr><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h2><ul><li>对象字面量<pre><code>var person = {  name: &#39;Kobe&#39;,  age: &#39;40&#39;,  profession: &#39;篮球运动员&#39;,  sports: function() {    console.log(&#39;打篮球&#39;);  }}</code></pre></li><li>通过<code>new Object()</code>创建<pre><code>// 调用构造函数在内存中创建一个空的对象 var person = new Object();// 添加成员和方法person.name = &#39;Kobe&#39;;person.age = 40;person.profession = &#39;篮球运动员&#39;;person.sports = function() {  console.log(&#39;打篮球&#39;);}</code></pre></li><li>工厂方法<pre><code>function createPerson(name,age,profession) {  var person = new Object();  person.name = name;  person.age = age;  person.profession = profession;  person.sports = function() {    console.log(this.name + &#39;打篮球&#39;);  }  return person;}var person1 = createPerson(&#39;Kobe&#39;,40,&#39;篮球运动员&#39;);var person2 = createPerson(&#39;James&#39;,44,&#39;篮球运动员&#39;);</code></pre></li><li>自定义构造函数<pre><code>// 帕斯卡命名 每个单词的第一个字母大写function Person(name,age,profession) {  // this执行当前对象  this.name = name;  this.age = age;  this.profession = profession;  this.sports = function() {    console.log(this.name + &#39;打篮球&#39;);  }}var person1 = new Person(&#39;Kobe&#39;,40,&#39;篮球运动员&#39;);var person2 = new Person(&#39;James&#39;,44,&#39;篮球运动员&#39;);</code></pre></li></ul><hr><h2 id="new关键字的执行过程"><a href="#new关键字的执行过程" class="headerlink" title="new关键字的执行过程"></a><code>new</code>关键字的执行过程</h2><ul><li>在内存中创建一个空的对象</li><li>让函数中的<code>this</code>指向刚刚创建的对象</li><li>执行构造函数，在构造函数中设置属性和方法</li><li>返回了当前对象（内部处理）</li></ul><hr><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a><code>this</code>指向</h2><ul><li>函数中的<code>this</code>指向<code>window</code><pre><code>function fun() {  console.log(this); // window}</code></pre></li><li>方法中的<code>this</code>指向当前方法所属的对象<pre><code>var obj = {  name: &#39;Kobe&#39;,  fn: function() {    console.log(this); // Object--&gt;obj  }}</code></pre></li><li>构造函数中的<code>this</code>指向构造函数创建的对象<pre><code>function Fun() {  this.name = &#39;Kobe&#39;;  console.log(this); }</code></pre></li><li>事件处理函数中的<code>this</code>指向事件源</li></ul><hr><h2 id="遍历和删除对象的属性"><a href="#遍历和删除对象的属性" class="headerlink" title="遍历和删除对象的属性"></a>遍历和删除对象的属性</h2><pre><code>  var obj = {    name: &#39;Kobe&#39;,    age: 40,    sayHi: function() {      console.log(&#39;hello&#39;);    }  }  // 遍历 for in --&gt; key 为属性  for (var key in obj) {    console.log(key + &#39;=&gt;&#39; + obj[key])  }  // 删除属性  delete obj.name;  delete obj.sayHi;</code></pre><hr><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li><code>Math</code>对象<ul><li><code>Math.PI</code> 圆周率</li><li><code>Math.random()</code> 生成随机数</li><li><code>Math.floor()/Math.ceil()</code> 向下取整/向上取整</li><li><code>Math.round()</code> 取整，四舍五入</li><li><code>Math.abs()</code> 绝对值</li><li><code>Math.max()/Math.min()</code> 最大值/最小值</li><li><code>Math.sin()/Math.cos()</code> 正弦/余弦</li><li><code>Math.power()/Math.sqrt()</code> 指数幂/平凡根</li></ul></li><li><code>Array</code>对象<ul><li>判断一个参数是否是数组<pre><code>var arr = [];// instanceof console.log(arr instanceof Array); // true// H5提出isArray()方法 具有浏览器兼容性问题console.log(Array.isArray(arr)); // true</code></pre></li><li>栈（先进后出）操作方法：<code>push</code>-&gt;压栈 <code>pop</code>-&gt;出栈</li><li>队列（后进先出）操作方法：<code>shift</code>-&gt;取出第一项 <code>unshift</code>-&gt;在开头插入项 <code>push</code>-&gt;在最后面追加项</li><li>排序方法：<code>sort</code> <code>reverse</code><pre><code>// 模拟内部sort实现function sort(arr, fun) {  for (var i = 0; i &lt; arr.length - 1; i++) {    var isSort = true;    for (var j = 0; j &lt; arr.length - 1 - i; j++) {      if (fun(arr[j], arr[j + 1]) &gt; 0) {        isSort = false;        var temp = arr[j];        arr[j] = arr[j + 1];        arr[j + 1] = temp;      }    }    if (isSort) break;  }}</code></pre></li><li><code>concat</code>方法：用于拼接两个数组</li><li><code>slice</code>方法：从数组中截取一个新的数组，不影响原来数组</li><li><code>splice</code>方法：对数组进行删除、替换</li><li>位置方法：<code>indexOf</code> <code>lastIndexOf</code> 找到返回下标，否则返回-1</li></ul></li></ul><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串的不可变（导致大量字符串拼接影响性能）</li><li>字符方法<ul><li><code>charAt</code> 获取指定位置处的字符</li><li><code>charCodeAt</code> 获取指定位置处字符的ASCII编码</li></ul></li><li>字符串方法（不会修改原有字符串）<ul><li><code>concat</code> 拼接字符串</li><li><code>slice</code> 从start位置开始，获取到end位置，不包括end</li><li><code>substring</code> 从start位置开始，截取到end位置，不包括end</li><li><code>substr</code> 从start位置开始，截取length个字符</li><li><code>indexOf</code> 返回指定内容在字符串中的索引</li><li><code>lastIndexOf</code> 与<code>indexOf</code>方向相反</li><li><code>trim</code> 去除字符串前后的空白</li><li><code>replace</code> 替换</li><li><code>split</code> 用字符切割字符串，返回一个数组</li><li><code>to(Locale)UpperCase</code> 转换大写</li><li><code>to(Locale)LowerCase</code> 转换小写</li><li><code>search</code> 支持正则表达式</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;作用域（变量或者函数可以起作用的访问范围）&quot;&gt;&lt;a href=&quot;#作用域（变量或者函数可以起作用的访问范围）&quot; class=&quot;headerlink&quot; title=&quot;作用域（变量或者函数可以起作用的访问范围）&quot;&gt;&lt;/a&gt;作用域（变量或者函数可以起作用的访问范围）&lt;/
      
    
    </summary>
    
    
      <category term="-JavaScript回顾" scheme="http://yoursite.com/categories/JavaScript%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="-JavaScript回顾" scheme="http://yoursite.com/tags/JavaScript%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router</title>
    <link href="http://yoursite.com/2020/06/23/Vue-Router/"/>
    <id>http://yoursite.com/2020/06/23/Vue-Router/</id>
    <published>2020-06-23T00:13:37.000Z</published>
    <updated>2020-06-26T12:41:34.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是前端渲染？什么是后端渲染？"><a href="#什么是前端渲染？什么是后端渲染？" class="headerlink" title="什么是前端渲染？什么是后端渲染？"></a>什么是前端渲染？什么是后端渲染？</h2><hr><h2 id="什么是前后端分离？"><a href="#什么是前后端分离？" class="headerlink" title="什么是前后端分离？"></a>什么是前后端分离？</h2><ul><li>有了Ajax的出现，才有了前后端分离的开发模式</li><li>后端只提供数据API，前端通过Ajax获取数据，并通过JavaScript将数据渲染到页面</li><li>优势：前后端责任清晰，前端专注于交互和可视化，后端专注于数据</li><li>移动端出现，后端的API不需要任何处理</li></ul><hr><h2 id="什么是前端路由？什么是后端路由"><a href="#什么是前端路由？什么是后端路由" class="headerlink" title="什么是前端路由？什么是后端路由"></a>什么是前端路由？什么是后端路由</h2><hr><h2 id="单页面富应用（SPA）"><a href="#单页面富应用（SPA）" class="headerlink" title="单页面富应用（SPA）"></a>单页面富应用（SPA）</h2><ul><li>在前后端分离的基础上加了一层前端路由</li><li>由前端来维护一套路由规则</li></ul><hr><h2 id="如何在改变URL的同时让页面不刷新"><a href="#如何在改变URL的同时让页面不刷新" class="headerlink" title="如何在改变URL的同时让页面不刷新"></a>如何在改变URL的同时让页面不刷新</h2><ul><li>通过<code>location.hash = &#39;foo&#39;</code><br><code>http://localhost:8080/#/foo</code></li><li>通过h5中的<code>history.pushState({},&#39;&#39;,&#39;home&#39;)</code>修改（类似栈结构）<br><code>http://localhost:8080/home</code></li><li>通过h5中的<code>history.replaceState({},&#39;&#39;,&#39;home&#39;)</code>修改（替换）</li><li>返回<code>history.back()</code>等价于<code>history.go(-1)</code>；向前<code>history.forward()</code>等价于<code>history.go(1)</code></li></ul><hr><h2 id="三大框架的路由实现"><a href="#三大框架的路由实现" class="headerlink" title="三大框架的路由实现"></a>三大框架的路由实现</h2><ul><li>Angular中的ngRouter</li><li>React中的ReactRouter</li><li>Vue中的vue-router</li></ul><hr><h2 id="vue-router基于路由和组件"><a href="#vue-router基于路由和组件" class="headerlink" title="vue-router基于路由和组件"></a>vue-router基于路由和组件</h2><ul><li>路由用于设定访问路径，将路径和组件映射起来</li><li>在SPA中，页面路径的改变就是组件的切换</li></ul><hr><h2 id="安装和使用vue-router"><a href="#安装和使用vue-router" class="headerlink" title="安装和使用vue-router"></a>安装和使用vue-router</h2><ul><li>通过<code>npm install vue-router --save</code>安装  </li><li>在模块化工程中使用它<ul><li>导入路由对象，并调用<code>Vue.use(Router)</code></li><li>创建路由实例，传入路由映射配置</li><li>在Vue实例中挂载创建的路由实例</li></ul></li><li>使用vue-router的步骤<ul><li>创建路由组件并配置路由映射<pre><code>export default new Router({  routes: [    {      path: &#39;/home&#39;,      component: Home    },    {      path: &#39;/about&#39;,      component: About    }  ]})</code></pre></li><li>挂载路由<pre><code>new Vue({  el: &#39;#app&#39;,  router,  render: h =&gt; h(App)})</code></pre></li><li>使用，通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;router-link to=&quot;/home&quot;&gt;to home&lt;/router-link&gt;  &lt;router-link to=&quot;/about&quot;&gt;to about&lt;/router-link&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;</code></pre></li></ul></li><li>路由的默认值和修改history模式（默认hash模式）<pre><code>routes: [  {    path: &#39;&#39;,    redirect: &#39;/about&#39;  }],mode: &#39;history&#39;</code></pre></li><li><code>&lt;router-link&gt;</code>的其他属性<ul><li>tag：可以指定<router-link>之后渲染成什么组件<br><code>&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;&lt;/router-link&gt;</code></li><li>replace：replace不会留下历史记录，也就是指定replace后，返回键不能返回上一个页面</li><li>active-class：当<code>&lt;router-link&gt;</code>对应的路由匹配成功时，会自动给当前元素设置一个router-link-active的class，要想修改只需加入<code>active-class=&quot;&quot;</code>或者再routes中加入<code>linkActiveClass: &#39;&#39;</code>属性</li></ul></li></ul><hr><h2 id="路由的懒加载"><a href="#路由的懒加载" class="headerlink" title="路由的懒加载"></a>路由的懒加载</h2><ul><li><p>当打包构建应用时，JavaScript包会变得非常大，影响页面加载</p></li><li><p>把不同路由对应的组件分割成不同的的代码块，当路由访问的时候才加载对应组件，会更高效</p></li><li><p>路由懒加载的方式</p><ul><li>方式一：结合Vue的异步组件和Webpack的代码分析（看着就烦）<pre><code>const Home = resolve =&gt; {  require.ensure([&#39;../components/Home.vue&#39;],()=&gt; {    resolve(require(&#39;../components/Home.vue&#39;))  })}</code></pre></li><li>方式二：AMD写法<pre><code>const Home = resolve =&gt; require([&#39;../components/Home.vue&#39;],resolve)</code></pre></li><li>方式三：ES6中的简单写法<pre><code>const Home = () =&gt; import(&#39;../components/Home.vue&#39;)</code></pre></li></ul></li><li><p>路由的嵌套</p><pre><code>  {    path: &#39;/home&#39;,    component: Home,    children: [      {        path: &#39;&#39;,        redirect: &#39;news&#39;      },      {        path: &#39;news&#39;,        component: News      },      {        path: &#39;message&#39;,        component: Message      }    ]  }</code></pre></li><li><p>路由传递参数</p><ul><li><p>通过param类型</p><ul><li>配置路由格式：<code>/router/:id</code></li><li>传递方式：在path后面跟上对应的值</li><li>传递后形成的路径：<code>/router/123</code><pre><code>{path: &#39;/user/:userId&#39;,component: User}&lt;router-link v-bind:to=&quot;&#39;/user/&#39;+userId&quot; replace&gt;用户&lt;/router-link&gt;// 获取userId$route.params.userId</code></pre></li></ul><p>```</p></li><li><p>通过query类型</p><ul><li>配置路由格式（普通配置）：<code>/router/</code></li><li>传递方式：对象中使用query的key作为传递方式</li><li>传递后形成的路径：<code>/router?id=123</code><pre><code>{path: &#39;/profile&#39;,component: Profile}&lt;router-link :to=&quot;{path: &#39;/profile&#39;, query: {name: &#39;xxx&#39;,age: 18,gender: &#39;man&#39;}}&quot; replace&gt;档案&lt;/router-link&gt;// 获取query$route.query</code></pre></li></ul></li></ul></li><li><p>keep-alive</p><ul><li>是Vue内置的组件，可以使被包含的组件包含状态，避免重新渲染<ul><li>include属性：字符串或正则，只有匹配的组件才会被缓存</li><li>exclude属性：字符串或正则，任何匹配的组件都不会被缓存<pre><code>// 排除Profile 传入组件的name 多个之间用&#39;,&#39;隔开，&#39;,&#39;后不要加空格&lt;keep-alive exclude=&quot;Profile&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre></li></ul></li><li><code>&lt;router-view&gt;</code>放在<code>&lt;keep-alive&gt;</code>中，所有路径匹配到的视图组件都会被缓存</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是前端渲染？什么是后端渲染？&quot;&gt;&lt;a href=&quot;#什么是前端渲染？什么是后端渲染？&quot; class=&quot;headerlink&quot; title=&quot;什么是前端渲染？什么是后端渲染？&quot;&gt;&lt;/a&gt;什么是前端渲染？什么是后端渲染？&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;什么是前
      
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="-Vue-Router -前端路由" scheme="http://yoursite.com/tags/Vue-Router-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Vue-CLI</title>
    <link href="http://yoursite.com/2020/06/18/Vue-CLI/"/>
    <id>http://yoursite.com/2020/06/18/Vue-CLI/</id>
    <published>2020-06-18T03:11:34.000Z</published>
    <updated>2020-06-22T10:53:27.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-CLI的使用"><a href="#Vue-CLI的使用" class="headerlink" title="Vue CLI的使用"></a>Vue CLI的使用</h2><ul><li>安装Vue脚手架<br><code>npm install -g @vue/cli</code></li><li>拉取 2.x 模板 (旧版本)<br><code>npm install -g @vue/cli-init</code></li><li>Vue CLI2初始化项目<br><code>vue init webpack my-project</code></li><li>runtime+compiler和runtime-only的区别在于main.js文件<ul><li>runtime+compiler中的main.js<pre><code>new Vue({  el: &#39;#app&#39;,  // components: { App },  // template: &#39;&lt;App/&gt;&#39;  // 普通用法  render: function(createElement) {    return createElement(&#39;标签&#39;,    {标签的属性},    [标签的内容],    createElement(&#39;标签&#39;,[标签内容]))  }  // 传入组件对象（就和runtime-only相同了）  render: functiong(createElement){    return createElement(&#39;组件名称&#39;)  }})</code></pre></li><li>runtime-only中的main.js<pre><code>new Vue({  el: &#39;#app&#39;,  render: h =&gt; h(App)})</code></pre></li><li>这里借用一篇博客来理解<br><a href="https://blog.csdn.net/Xidian2850/article/details/103793913" target="_blank">文殊师利法王子</a></li></ul></li></ul><hr><h2 id="Vue-CLI3"><a href="#Vue-CLI3" class="headerlink" title="Vue CLI3"></a>Vue CLI3</h2><ul><li>创建项目<br><code>vue create 项目名称</code></li><li>配置的三种方法<ul><li>通过启动服务器配置（GUI界面配置）<br><code>vue ui</code></li><li>通过修改隐藏配置文件<br>文件隐藏在node_modules/@vue/cli-service/webpack.config.js</li><li>在当前目录下创建vue.config.js文件配置  <ul><li>提交到本地仓库<br><code>git commit -m &quot;描述&quot;</code>  </li><li>文件中导出配置：  <pre><code>  module.exports = {  }</code></pre></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue-CLI的使用&quot;&gt;&lt;a href=&quot;#Vue-CLI的使用&quot; class=&quot;headerlink&quot; title=&quot;Vue CLI的使用&quot;&gt;&lt;/a&gt;Vue CLI的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装Vue脚手架&lt;br&gt;&lt;code&gt;npm install -g
      
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="-Vue脚手架" scheme="http://yoursite.com/tags/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="http://yoursite.com/2020/06/16/Webpack/"/>
    <id>http://yoursite.com/2020/06/16/Webpack/</id>
    <published>2020-06-16T11:49:49.000Z</published>
    <updated>2020-06-18T02:43:20.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack（打包之后就没有用了）的安装"><a href="#Webpack（打包之后就没有用了）的安装" class="headerlink" title="Webpack（打包之后就没有用了）的安装"></a>Webpack（打包之后就没有用了）的安装</h2><ul><li>先安装node</li><li>查看node版本<br><code>node -v</code></li><li>全局安装Webpack<br><code>npm install webpack@版本号 -g</code></li><li>本地安装Webpack 和项目同步<br><code>npm install webpack@版本号 --save-dev</code>（–save-dev是开发时依赖，项目打包后不需要继续使用）</li><li>查看webpack版本<br><code>webpack --version</code></li></ul><hr><h2 id="Webpack文件夹解析"><a href="#Webpack文件夹解析" class="headerlink" title="Webpack文件夹解析"></a>Webpack文件夹解析</h2><ul><li><p><strong>dist</strong>文件夹：用于存放之后打包的文件</p></li><li><p><strong>src</strong>文件夹：用于存放源文件</p></li><li><p><strong>index.html</strong>：首页</p></li><li><p><strong>package.json</strong>：通过<code>npm init</code>生成的，<strong>npm</strong>包管理的文件</p></li><li><p><strong>webpack.config.js</strong>：配置文件（文件名不可随意修改）  </p><pre><code>  // npm init   npm install  // 导入node中的path模块  const path = require(&#39;path&#39;);  // 映射webpack &#39;入口文件&#39; &#39;出口文件&#39;  module.exports = {      entry: &#39;./src/index.js&#39;,      output: {          path: path.join(__dirname,&#39;dist&#39;),          filename: &#39;bundle.js&#39;      }  }</code></pre></li><li><p><strong>package.json</strong>：依赖文件  </p><pre><code>  {      &quot;name&quot;: &quot;meetwebpack&quot;,      &quot;version&quot;: &quot;1.0.0&quot;,      &quot;description&quot;: &quot;&quot;,      &quot;main&quot;: &quot;webpack.config.js&quot;,      &quot;scripts&quot;: {          &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,          // 用于 npm run build映射 相当于运行webpack命令 会优先去本地找webpack，然后再去全局找，只要在终端中运行webpack就是全局          &quot;build&quot;: &quot;webpack&quot;      },      &quot;author&quot;: &quot;&quot;,      &quot;license&quot;: &quot;ISC&quot;      // 开发时依赖（开发阶段使用）      &quot;devDependencies&quot;: {          &quot;webpack&quot;: &quot;^3.6.0&quot;      }      // 打包后使用的依赖      &quot;dependencies&quot;: {      }  }</code></pre></li></ul><hr><h2 id="Webpack扩充loader"><a href="#Webpack扩充loader" class="headerlink" title="Webpack扩充loader"></a>Webpack扩充loader</h2><ul><li>使用过程<ul><li>npm安装loader<br><code>npm install --save-dev css-loader</code><br><code>npm install style-loader --save-dev</code><br><code>npm install --save-dev less-loader less</code><br><code>npm install --save-dev url-loader</code><br><code>npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</code></li><li>webpack.comfig.js中的modules关键字下配置，加入以下代码  <pre><code>entry: &#39;./src/index.js&#39;,    output: {    path: path.join(__dirname,&#39;dist&#39;),    filename: &#39;bundle.js&#39;,    // file-loader加载图片时配置图片路径    publicPath: &#39;dist/&#39;},module: {    rules: [        {            // 正则 .css结尾            test: /\.css$/,            // css-loader只负责加载            // style-loader负责将样式添加到dom中            // webpack读取多个loader时从右往左读            use: [ &#39;style-loader&#39;,&#39;css-loader&#39; ]        },        {            test: /\.less$/,            use: [{                loader: &quot;style-loader&quot; // creates style nodes from JS strings            }, {                loader: &quot;css-loader&quot; // translates CSS into CommonJS            }, {                loader: &quot;less-loader&quot; // compiles Less to CSS            }]        },        {            test: /\.(png|jpg|gif)$/,            use: [                {                    loader: &#39;url-loader&#39;,                    options: {                        // 加载的图片小于limit时，会将图片编译成base64字符串形式，大于limit要使用file-loader加载（这里要配置publicPath）                        limit: 8192,                        // 规范打包后的图片名字 img文件夹/原来的图片名.8位hash值.原有扩展名                        name: &#39;img/[name].[hash:8].[ext]&#39;                    }                }            ]        },        {            test: /\.js$/,            // 排除：当打包es6--&gt;es5转化时 只转化src文件夹内的内容            exclude: /(node_modules|bower_components)/,            use: {                loader: &#39;babel-loader&#39;,                options: {                    // presets: [&#39;@babel/preset-env&#39;]                    presets: [&#39;es2015&#39;]                }            }        }    ]}</code></pre></li></ul></li></ul><hr><h2 id="Webpack引入Vue"><a href="#Webpack引入Vue" class="headerlink" title="Webpack引入Vue"></a>Webpack引入Vue</h2><ul><li>npm下载Vue<br><code>npm install vue --save</code></li><li>打包编译时报<code>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</code>错误<ul><li>解释：<ul><li>runtime-only-&gt;代码中不可以有任何的template</li><li>runtime-compliler-&gt;代码中可以有template，因为有compliler可以编译template</li></ul></li><li>解决（配置webpack.config.js）:<pre><code>module.exports = {    entry: &#39;./src/index.js&#39;,    output: {        path: path.join(__dirname,&#39;dist&#39;),        filename: &#39;bundle.js&#39;,        publicPath: &#39;dist/&#39;    },    module: {    },    resolve: {        // 别名        alias: {        // 指定Vue版本 其中含有compliler        &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;        }    }}</code></pre></li></ul></li><li>SPA（simple page web application单页面应用：只有一个html）<ul><li>可以通过vue-router（前端路由跳转）</li></ul></li><li>new Vue中的el属性和template属性同时存在时 Vue内部会把template替换到el挂载的元素</li><li>安装vue-loader（加载Vue文件）和vue-template-compiler（编译Vue）<br><code>npm install vue-loader vue-template-compiler --save-dev</code></li><li>webpack.config.js中配置vue-loader  <pre><code>module: {  rules: [      {          test:/\.vue$/,          use: [ &#39;vue-loader&#39; ]      }  ]}</code></pre></li></ul><hr><h2 id="Webpack中的plugin"><a href="#Webpack中的plugin" class="headerlink" title="Webpack中的plugin"></a>Webpack中的plugin</h2><ul><li>plugin<ul><li>plugin是插件的意思，用于对某个现有的架构进行扩展</li><li>webpack中的插件就是对webpack现有功能的扩展（比如打包优化、文件压缩）</li></ul></li><li>loader和plugin的区别<ul><li>loader主要用于转换某些类型的模块，是一个转换器</li><li>plugin是插件，是对webpack本身的扩展，是一个扩展器</li></ul></li><li>plugin的使用<ul><li>通过npm安装plugin（webpack已内置的插件无需安装）</li><li>在webpack.config.js中的plugins中配置插件</li></ul></li><li>plugin类型<ul><li>BannerPlugin：webpack自带插件，为打包的文件添加版权声明  <pre><code>```const webpack = require(&#39;webpack&#39;)module.exports = {    plugins: [        new webpack.BannerPlugin(&#39;最终版权归...所有&#39;)    ]}```</code></pre></li><li>HtmlWebpackPlugin：打包html的插件<ul><li>注：发布项目时，dist文件夹中要有index.html</li><li>自动生成一个index.html文件（可以指定模板生成）</li><li>将打包的js文件，自动通过script标签插入到body中</li><li>安装HtmlWebpackPlugin<pre><code>  npm install html-webpack-plugin --save-dev</code></pre><ul><li>配置webpack.config.js中的plugins<pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)plugins: [    // 需要注释掉出口文件中的publicPath    new HtmlWebpackPlugin({        // 指定打包时的模板        template: &#39;index.html&#39;    })]</code></pre></li></ul></li></ul></li><li>uglifyjs-webpack-plugin：压缩打包后的js文件<ul><li>安装<br>  <code>npm uglifyjs-webpack-plugin@1.1.1 --save-dev</code></li><li>配置<pre><code>  const uglifyJsWebpackPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)  plugins: [      new uglifyJsWebpackPlugin()  ]</code></pre></li></ul></li></ul></li></ul><hr><h2 id="基于node-js（使用express）搭建本地服务器"><a href="#基于node-js（使用express）搭建本地服务器" class="headerlink" title="基于node.js（使用express）搭建本地服务器"></a>基于node.js（使用express）搭建本地服务器</h2><ul><li>安装模块<br><code>npm install webpack-dev-server@2.9.3 --save-dev</code></li><li>devserver是webpack中的一个选项，有以下属性<ul><li>contentBase：为哪个文件夹提供本地服务，默认是根文件夹，改为./dist</li><li>port：端口号</li><li>inline：页面实时刷新</li><li>historyApiFallback：在SPA模式中，依赖HTML5的history模式</li><li>配置webpack.config.js文件  <pre><code>```devServer: {    contentBase: &#39;./dist&#39;,    inline: true,    // 自动打开网页    open: true}```  </code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Webpack（打包之后就没有用了）的安装&quot;&gt;&lt;a href=&quot;#Webpack（打包之后就没有用了）的安装&quot; class=&quot;headerlink&quot; title=&quot;Webpack（打包之后就没有用了）的安装&quot;&gt;&lt;/a&gt;Webpack（打包之后就没有用了）的安装&lt;/
      
    
    </summary>
    
    
      <category term="-Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="-Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>HTML/CSS面试题解</title>
    <link href="http://yoursite.com/2020/06/16/html-css-interview/"/>
    <id>http://yoursite.com/2020/06/16/html-css-interview/</id>
    <published>2020-06-15T23:48:13.000Z</published>
    <updated>2020-06-16T13:56:23.067Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>下列哪些功能默认支持跨域？  </p><p> A. LocalStorage<br> B. Image<br> C. canvas<br> D. iframe </p><pre><code> 答案：B D 注解：     跨域：发起请求与指向资源域不相同（协议+域名+端口）     常见指向资源的部件有：&lt;a&gt;,&lt;form&gt;,&lt;script&gt;,&lt;img&gt;,&lt;iframe&gt;,&lt;link&gt;等标签以及Ajax请求     介绍两个概念：         1. localStorage：类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；当页面被关闭时，存储在 sessionStorage 的数据会被清除。         2. 同源策略（same-origin policy）：是浏览器执行的一种安全措施，目的是为了保证用户信息的安全，防止恶意的网站窃取数据。     受到同源策略的影响，localStorage是无法进行跨域请求的，可以利用postMessage+ifarme来实行跨域通信     HTML 规范中图片有一个 crossOrigin 属性，结合合适的 CORS 响应头，就可以实现在canvas中使用跨域 &lt;img&gt; 元素的图像</code></pre></li><li><p>下列说法错误的是：</p><p>A. 在Blink和WebKit的浏览器中，某个元素具有3D或透视变换（perspective transform）的CSS属性，会让浏览器创建单独的图层。<br>B. 我们平常会使用left和top属性来修改元素的位置，但left和top会触发重布局，取而代之的更好方法是使用translate，这个不会触发重布局。<br>C. 移动端要想动画性能流畅，应该使用3D硬件加速，因此最好给页面中的元素尽量添加translate3d或者translateZ(0)来触发3D硬件加速。<br>D. 解决浏览器渲染的性能问题时，首要目标就是要避免层的重绘和重排。 </p><pre><code>答案：C注解：   滥用硬件加速会导致严重性能问题，因为它增加了内存使用，并且它会导致移动端电池寿命减少</code></pre></li><li><p>下面有关CSS中link和@import的区别，描述错误的是</p><p>A. link属于XHTML标签，而@import完全是CSS提供的一种方式<br>B. 当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载<br>C. link在支持CSS的浏览器上都支持而@import只在5.0以上的版本有效<br>D. 当使用javascript控制dom去改变样式的时候，只能使用@import方式</p><pre><code>答案：D注解：     关于link与@import的区别:         区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。         区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。         区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。         区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;下列哪些功能默认支持跨域？  &lt;/p&gt;
&lt;p&gt; A. LocalStorage&lt;br&gt; B. Image&lt;br&gt; C. canvas&lt;br&gt; D. iframe &lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 答案：B D
 注解：
     跨域：发起请求与指向资源域
      
    
    </summary>
    
    
      <category term="-面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="-html/css面试" scheme="http://yoursite.com/tags/html-css%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件化</title>
    <link href="http://yoursite.com/2020/06/12/vue-module/"/>
    <id>http://yoursite.com/2020/06/12/vue-module/</id>
    <published>2020-06-12T09:26:41.000Z</published>
    <updated>2020-08-03T08:53:50.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a>Vue组件化思想</h2><div style="text-align: center"><p><img src="/images/module.png" alt="Vue组件树"></p></div>  <ul><li><p>Vue提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用</p></li><li><p>任何应用都会被抽象成一棵组件树</p></li><li><p>组件使用</p><ul><li>创建组件构造器<br><code>const cpnC = Vue.extend({template:`&lt;div&gt;&lt;/div&gt;`})</code></li><li>注册组件<br><code>Vue.component(注册组件的标签名,组件构造器)</code></li><li>使用组件<br><code>&lt;组件标签名&gt;&lt;/组件标签名&gt;</code></li></ul></li><li><p>全局组件和局部组件</p><ul><li>全局组件可以在多个Vue的实例下使用<br><code>Vue.component(注册组件的标签名,组件构造器)</code></li><li>在Vue实例中注册即为局部组件<pre><code>const app = new Vue({  el: &#39;#app&#39;,  components: {    // cpn为使用组件时的标签名    cpn: 组件构造器(cpnC)  }})</code></pre></li></ul></li><li><p>组件注册的语法糖</p><ul><li>全局组件<pre><code>Vue.component(&#39;cpn&#39;, {  template: `    &lt;div&gt;      &lt;h2&gt;&lt;/h2&gt;    &lt;/div&gt;  `})</code></pre></li><li>局部组件<pre><code>const app = new Vue({  el: &#39;app&#39;,  components: {    &#39;cpn&#39;: {      template: {        &lt;div&gt;           &lt;h2&gt;&lt;/h2&gt;        &lt;/div&gt;      }    }  }})</code></pre></li></ul></li><li><p>组件模板分离</p><ul><li><p>利用<code>&lt;script&gt;</code></p><pre><code>&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;h2&gt;&lt;/h2&gt;  &lt;/div&gt;&lt;/script&gt;  Vue.component(&#39;cpn&#39;,{  template: &#39;#cpn&#39;})</code></pre></li><li><p>利用<code>&lt;template&gt;</code></p><pre><code>&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;h2&gt;模板分离&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;Vue.component(&#39;cpn&#39;,{  template: &#39;#cpn&#39;})</code></pre></li></ul></li></ul><hr><h2 id="组件数据的存放"><a href="#组件数据的存放" class="headerlink" title="组件数据的存放"></a>组件数据的存放</h2><ul><li>组件对象有一个<strong>data</strong>属性(也有<strong>methods</strong>属性)</li><li><strong>data</strong>属性必须是一个函数</li><li>函数的返回值是一个对象，对象中存储</li><li><strong>data</strong>中为什么必须是个函数？</li></ul><hr><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><ul><li><p>通过<code>props</code>向子组件传递数据</p><ul><li><p>方式一：字符串数组，数组中的字符串就是传递时的名称</p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;cpn :cbooks=&quot;books&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in cbooks&quot;&gt;{{item}}&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;const cpn = {  template: &#39;#cpn&#39;,  props: [&#39;cbooks&#39;]};const app = new Vue({  el: &#39;#app&#39;,  data: {    books: [&#39;三国演义&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;水浒传&#39;]  },  components: {    cpn  }});</code></pre></li><li><p>方式二：对象，可设置传递的类型，也可设置默认值 </p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;cpn :cbooks=&quot;books&quot; :cmessage=&quot;message&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in cbooks&quot;&gt;{{item}}&lt;/li&gt;  &lt;/ul&gt;  &lt;h2&gt;{{cmessage}}&lt;/h2&gt;&lt;/template&gt;const cpn = {  template: &#39;#cpn&#39;,  props: {    // cbooks: Array    cbooks: {      type: Array,  // 为数组或对象时，默认值必须是一个函数      difault() {        return []      }    }    cmessage: {      type: String,      default: &#39;hi&#39;,      required: true, // 必须传值    }  }};const app = new Vue({  el: &#39;#app&#39;,  data: {    books: [&#39;三国演义&#39;,&#39;西游记&#39;,&#39;红楼梦&#39;,&#39;水浒传&#39;],    message: &#39;hello&#39;  },  components: {    cpn  }});</code></pre></li></ul></li><li><p>通过事件(自定义事件 emit发射出去)向父组件发送消息</p><pre><code>&lt;!--父组件--&gt;&lt;div id=&quot;app&quot;&gt;  &lt;cpn @item-click=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--子组件--&gt;&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;button v-for=&quot;item in categories&quot; @click=&quot;btnClick(item)&quot;&gt;{{item.name}}&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const cpn = {  template: &#39;#cpn&#39;,  data() {    return {      categories: [        {id: &#39;aaa&#39;, name: &#39;热门&#39;},        {id: &#39;bbb&#39;, name: &#39;手机&#39;},        {id: &#39;ccc&#39;, name: &#39;家电&#39;},        {id: &#39;ddd&#39;, name: &#39;电脑&#39;}      ]    }  },  methods: {    btnClick(item) {      this.$emit(&#39;item-click&#39;, item)    }  }}const app = new Vue({  el: &#39;#app&#39;,  data: {  },  components: {    cpn  },  methods: {    cpnClick(item) {      console.log(item.name)    }  }})&lt;/script&gt;</code></pre></li></ul><hr><h2 id="父子组件的访问"><a href="#父子组件的访问" class="headerlink" title="父子组件的访问"></a>父子组件的访问</h2><ul><li>父组件访问子组件<ul><li>使用$children(是个数组类型 不建议使用)</li><li>使用$refs(是个对象类型 默人为空对象 给模板加入ref属性)</li></ul></li><li>子组件访问父组件<ul><li>使用$parent</li></ul></li><li>访问根组件<ul><li>使用$root</li></ul></li></ul><hr><h2 id="插槽-抽取共性，保留不同"><a href="#插槽-抽取共性，保留不同" class="headerlink" title="插槽(抽取共性，保留不同)"></a>插槽(抽取共性，保留不同)</h2><ul><li><p><code>slot</code>的使用</p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;cpn&gt;    &lt;div&gt;      &lt;i&gt;i标签&lt;/i&gt;      &lt;span&gt;span标签&lt;/span&gt;    &lt;/div&gt;  &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;h2&gt;子组件&lt;/h2&gt;    &lt;!--默认值--&gt;    &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><p>具名插槽</p><ul><li><code>slot</code>使用<pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;cpn&gt;    &lt;button slot=&quot;left&quot;&gt;返回&lt;/button&gt;    &lt;span slot=&quot;center&quot;&gt;替换中间&lt;/span&gt;  &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt;  &lt;div&gt;    &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt;    &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt;    &lt;slot name=&quot;right&quot;&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li><li><code>slot</code>官方已经弃用，改为<code>v-slot</code>，并且<code>v-slot</code>只能添加在<code>&lt;template&gt;</code>上</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue组件化思想&quot;&gt;&lt;a href=&quot;#Vue组件化思想&quot; class=&quot;headerlink&quot; title=&quot;Vue组件化思想&quot;&gt;&lt;/a&gt;Vue组件化思想&lt;/h2&gt;&lt;div style=&quot;text-align: center&quot;&gt;

&lt;p&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="-Vue组件" scheme="http://yoursite.com/tags/Vue%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的Virtual DOM</title>
    <link href="http://yoursite.com/2020/06/11/vue-virtual-dom/"/>
    <id>http://yoursite.com/2020/06/11/vue-virtual-dom/</id>
    <published>2020-06-11T11:45:17.000Z</published>
    <updated>2020-06-30T11:06:59.752Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="-Virtual DOM" scheme="http://yoursite.com/tags/Virtual-DOM/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的MVVM</title>
    <link href="http://yoursite.com/2020/06/06/vue-mvvm/"/>
    <id>http://yoursite.com/2020/06/06/vue-mvvm/</id>
    <published>2020-06-06T08:25:58.000Z</published>
    <updated>2020-06-06T09:26:59.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVVM的理解"><a href="#MVVM的理解" class="headerlink" title="MVVM的理解"></a>MVVM的理解</h2><pre><code>MVVM拆开来即为Model-View-ViewModel，由View ViewModel Model三部分组成</code></pre><div style="text-align: center"><p><img src="/images/vue_mvvm.png" alt="Vue的数据驱动视图"></p></div><ul><li><strong>View层</strong><ul><li>视图层</li><li>前端开发中，通常为DOM</li><li>主要用与展示信息</li></ul></li><li><strong>Model层</strong><ul><li>数据层</li><li>可能是固定的数据，更多的是来自于网络请求</li></ul></li><li><strong>ViewModel层</strong><ul><li>视图模型层</li><li>是View和Model沟通的桥梁</li><li>一方面实现了数据绑定(<strong>Data Bindings</strong>),即将<strong>Model</strong>层数据的改变实时反应到<strong>View</strong>层中</li><li>另一方面实现了<strong>DOM</strong>监听(<strong>DOM Listener</strong>)，即监听<strong>DOM</strong>事件的发生，并改变对应的数据</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MVVM的理解&quot;&gt;&lt;a href=&quot;#MVVM的理解&quot; class=&quot;headerlink&quot; title=&quot;MVVM的理解&quot;&gt;&lt;/a&gt;MVVM的理解&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;MVVM拆开来即为Model-View-ViewModel，由View ViewMo
      
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="-Vue中的MVVM" scheme="http://yoursite.com/tags/Vue%E4%B8%AD%E7%9A%84MVVM/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础</title>
    <link href="http://yoursite.com/2020/06/05/vue/"/>
    <id>http://yoursite.com/2020/06/05/vue/</id>
    <published>2020-06-05T12:20:02.000Z</published>
    <updated>2020-10-22T10:02:24.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue安装的三种方式"><a href="#Vue安装的三种方式" class="headerlink" title="Vue安装的三种方式"></a>Vue安装的三种方式</h2><ol><li><p><strong>CDN引入</strong></p><ul><li><strong>开发环境版本，包含了有帮助的命令行警告</strong><br><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li><li><strong>生产环境版本，优化了尺寸和速度</strong><br><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;</code>  </li></ul></li><li><p><strong>官方下载引入</strong>  </p><ul><li>直接引入<code>&lt;script&gt;</code>标签</li></ul></li><li><p><strong>NPM安装</strong>  </p><ul><li><code>npm install vue</code></li></ul></li></ol><hr><h2 id="创建Vue实例传入的options"><a href="#创建Vue实例传入的options" class="headerlink" title="创建Vue实例传入的options"></a>创建Vue实例传入的options</h2><ul><li><strong>el</strong><ul><li>类型：string | HTMLElement</li><li>作用：决定之后Vue实例会管理哪一个DOM</li></ul></li><li><strong>data</strong><ul><li>类型：Object | Function</li><li>作用：Vue实例对应的数据对象</li></ul></li><li><strong>methods</strong><ul><li>类型：{ [key: string]: Function }</li><li>作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用</li></ul></li></ul><hr><h2 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h2><ol><li><strong>Mustache语法</strong>  <pre><code>&lt;div id=&quot;app&quot;&gt;   &lt;h2&gt;{{hello}}&lt;/h2&gt;   &lt;h2&gt;{{hello + ' ' + world}}&lt;/h2&gt;   &lt;h2&gt;{{hello}} {{world}}&lt;/h2&gt;   &lt;h2&gt;{{count * 2}}&lt;/h2&gt;&lt;/div&gt;&lt;script&gt;   const app = new Vue({      el: &#39;#app&#39;,      data: {         hello: &#39;hello&#39;,         world: &#39;world&#39;,         count: 100      }   })&lt;/script&gt;</code></pre></li><li><strong>v-once指令</strong><ul><li>该指令后不需要跟任何表达式</li><li>该指令表示元素和组件只渲染一次，不会随着数据的该笔而改变</li></ul></li><li><strong>v-html指令</strong><ul><li>该指令后面往往跟上一个string类型</li><li>会将string类型的html解析并渲染</li></ul></li><li><strong>v-text指令</strong><ul><li>该指令与<strong>Mustache</strong>语法比较相似，都是将数据显示在界面，但不够灵活，会覆盖标签内的内容</li><li>该指令接受一个string类型</li></ul></li><li><strong>v-pre指令</strong><ul><li>该指令后不需要跟任何表达式</li><li>该指令跳过解析，显示原本的内容</li></ul></li><li><strong>v-cloak指令</strong><ul><li>该指令后不需要跟任何表达式</li><li>斗篷</li></ul></li></ol><hr><h2 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h2><ul><li>该指令可以动态绑定属性<ol><li>使用方法  <pre><code>&lt;div id=&quot;app&quot;&gt;&lt;img v-bind:src=&quot;imgURL&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</code></pre></li><li>语法糖  <pre><code>&lt;div id=&quot;app&quot;&gt;&lt;img :src=&quot;imgURL&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</code></pre></li></ol></li><li>动态绑定class<ol><li>使用方法  <pre><code>&lt;style&gt;.active {  color: red;}&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;&lt;h2 :class=&quot;active&quot;&gt;hello&lt;/h2&gt;&lt;h2 :class=&quot;{类名1:boolean,类名2:boolean}&quot;&gt;hello&lt;/h2&gt;&lt;h2 :class=&quot;{key(css属性名):value(css属性值)}&quot;&gt;hello&lt;/h2&gt;&lt;/div&gt;</code></pre></li></ol></li></ul><hr><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ol><li><p>使用方法 </p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;h2&gt;{{fullStr}}&lt;/h2&gt;&lt;/div&gt;const app = new Vue({  el: &#39;#app&#39;,  data: {    firstStr: &#39;hello&#39;,    lastStr: &#39;world&#39;  },  computed: {    fullStr() {     return this.firstStr + &#39; &#39; + this.lastStr;    }  }})</code></pre></li><li><p>setter和getter方法  </p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;h2&gt;{{fullStr}}&lt;/h2&gt;&lt;/div&gt;const app = new Vue({  el: &#39;#app&#39;,  data: {    firstStr: &#39;hello&#39;,    lastStr: &#39;world&#39;  },  computed: {    fullStr: function() {      set: function(value) { //大多数情况不写      const str = value.split(&#39; &#39;);      this.firstStr = str[0];      this.lastStr = str[1];      },      get: function() {        return this.firstStr + &#39; &#39; + this.lastStr;      }    }  }})</code></pre></li><li><p><strong>computed</strong>和<strong>methods</strong>的对比</p><ul><li>多次使用时<strong>computed</strong>比<strong>methods</strong>性能高</li><li><strong>Vue</strong>内部对<strong>computed</strong>做了缓存，多次使用只调用一次，只有内容发生改变时，才会重新调用、缓存；而<strong>methods</strong>是使用几次调用几次</li></ul></li></ol><hr><h2 id="v-on事件监听"><a href="#v-on事件监听" class="headerlink" title="v-on事件监听"></a>v-on事件监听</h2><ul><li>绑定事件监听器</li><li>使用  <pre><code>&lt;button v-on:click=&quot;&quot;&gt;&lt;/button&gt;</code></pre></li><li>语法糖  <pre><code>&lt;button @click=&quot;&quot;&gt;&lt;/button&gt;</code></pre></li><li>v-on参数<ol><li>若方法不需要额外参数，方法后的()可以不添加</li><li>写方法时省略了()，但方法本身是需要一个参数的Vue会默认将浏览器生产的event对象作为参数传入</li><li>方法定义时，需要event对象，也需要其他参数<pre><code>&lt;button @click=&quot;btnClick(param,$event)&quot;&gt;&lt;/button&gt;</code></pre></li></ol></li><li>v-on修饰符<ol><li>阻止冒泡<strong>stop</strong>    <pre><code> &lt;div @click=&quot;divClick&quot;&gt;   &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt;</code></pre></li><li>阻止默认行为<strong>prevent</strong>    <pre><code> &lt;form action=&quot;baidu&quot;&gt;   &lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&quot;submitClick&quot;&gt; &lt;/form&gt;</code></pre></li><li>监听某个键盘键帽的点击(例如enter键)<pre><code> &lt;input type=&quot;text&quot; @keyup.enter=&quot;keyClick&quot;&gt;</code></pre></li><li>只触发一次回调<strong>once</strong><pre><code> &lt;button @click.once=&quot;buttonClick&quot;&gt;按钮&lt;/button&gt;</code></pre></li></ol></li></ul><hr><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li>v-if的使用(接收一个Boolean值)<pre><code>&lt;h2 v-if=&quot;true&quot;&gt;hello world&lt;/h2&gt;</code></pre></li><li>v-else的使用(v-if接收的是false是起作用)<pre><code>&lt;h2 v-if=&quot;isShow&quot;&gt;isShow为true时显示&lt;/h2&gt;  &lt;h2 v-else&gt;isShow为false时显示&lt;/h2&gt;</code></pre></li><li>v-else-if的使用(不建议)<pre><code>&lt;p v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;score&gt;=60&quot;&gt;合格&lt;/p&gt;&lt;p v-else&gt;不及格&lt;/p&gt;</code></pre></li><li>这里补充一下Vue中的Virtual DOM，也就是所谓的虚拟DOM<ul><li><strong>Virtual DOM</strong>其实就是一棵以JavaScript对象(VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。简单来说，可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名(tag)、属性(attrs)和子元素对象(children)三个属性。不同的框架对这三个属性的命名会有点差别</li><li><strong>Virtual DOM</strong>在Vue中做了什么<ol><li>供与真实DOM节点所对应的虚拟节点<strong>Vnode</strong></li><li>将虚拟节点Vnode和旧虚拟节点oldVnode进行对比，然后更新视图</li></ol></li></ul></li><li>v-show的使用<pre><code>&lt;h2 v-if=&quot;isShow&quot;&gt;isShow为true时显示&lt;/h2&gt;&lt;h2 v-show=&quot;isShow&quot;&gt;isShow为true时显示&lt;/h2&gt;</code></pre><ul><li>v-if与v-show控制元素显示的区别<ol><li>v-if，条件为false时，元素不会在DOM中存在；条件为true时，会重新创建元素</li><li>v-show，条件为false时，只是增加了行内样式：<code>display:none;</code>元素仍在DOM中存在</li><li>切换评率较高时使用v-show，只有一次使用v-if</li></ol></li></ul></li></ul><hr><h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><ul><li>v-for遍历数组<pre><code>&lt;ul&gt;  &lt;li v-for=&quot;(item,index) in books&quot;&gt;{{index+1}}-{{item}}&lt;/li&gt;&lt;/ul&gt;</code></pre></li><li>v-for遍历对象<pre><code>&lt;ul&gt;  &lt;li v-for=&quot;(value,key,index) in info&quot;&gt;{{key}}-{{value}}-{{index}}&lt;/li&gt;&lt;/ul&gt;</code></pre></li><li>数组中哪些方法是响应式的？<ol><li>push():在数组末尾添加元素</li><li>pop():删除数组最后一个元素</li><li>shift():删除数组第一个元素</li><li>unshift():在数组最前面添加元素</li><li>splice():可删除/替换/插入元素</li><li>sort():排序</li><li>reverse():反转</li><li>Vue.set(要修改的对象,修改的索引值,修改后的值)</li><li>通过索引值修改数组中的元素不可以做到响应式</li></ol></li></ul><hr><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul><li>本质包含两个操作<ul><li>v-bind绑定属性</li><li>v-on给当前元素绑定事件</li></ul></li><li>经常与<code>input</code> <code>textarea</code> <code>select</code>一块使用</li><li>值绑定<ul><li>标签中的值不写死，动态绑定</li></ul></li><li>v-model的修饰符<ul><li>lazy修饰符，不再实时绑定，当失去焦点或点击ENTER键时绑定  <pre><code>&lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;</code></pre></li><li>number修饰符，<code>input</code>限制只能输入数字时，v-model绑定的仍是string类型，加上number修饰符就是number类型  <pre><code>&lt;input type=&quot;number&quot; v-model.number=&quot;message&quot;&gt;</code></pre></li><li>trim修饰符，去除两端的空格<pre><code>&lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt;</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue安装的三种方式&quot;&gt;&lt;a href=&quot;#Vue安装的三种方式&quot; class=&quot;headerlink&quot; title=&quot;Vue安装的三种方式&quot;&gt;&lt;/a&gt;Vue安装的三种方式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;CDN引入&lt;/strong&gt;&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="-Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="-Vue基础" scheme="http://yoursite.com/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript算法笔记</title>
    <link href="http://yoursite.com/2020/06/04/algorithm-notes/"/>
    <id>http://yoursite.com/2020/06/04/algorithm-notes/</id>
    <published>2020-06-04T12:25:02.000Z</published>
    <updated>2020-06-19T14:06:29.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h3><ol><li><ul><li>给出一个字符串”adadfdfseffqdjhuserfefsefseetsdg”</li><li>要求：找出里边的字符串qdjhu</li><li>题解：<pre><code>   let string = &#39;adadfdfseffqdjhuserfefsefseetsdg&#39;   let search = &#39;qdjhu&#39;   // 找到search在string中开始的位置   let indexStart = string.indexOf(search)   let indexEnd = indexStart + search.length   let result  = string.substring(indexStart,indexEnd)   console.log(result)</code></pre></li></ul></li><li><ul><li>字符串转驼峰</li><li>例如：border-bottom-color -&gt; borderBottomColor</li><li>题解：<pre><code>   function strToHump(val) {   let arr = val.split(&#39;-&#39;)   return arr.reduce(function (pre,current,index) {       return pre + current.charAt(0).toUpperCase() + current.slice(1)   })   }</code></pre></li></ul></li><li><ul><li>找出字符串中出行次数最多的字符和个数</li><li>例如：abbcccddddd -&gt; 字符最多的是d，出现了5次</li><li>题解：<pre><code>   let str = &#39;abbcccddddd&#39;   let obj = str.split(&#39;&#39;).reduce(function (pre,cur) {   pre[cur] ? pre[cur]++ : pre[cur] = 1   return pre   }, {})   let num = 0   let result = &#39;&#39;   for(key in obj) {   if (obj[key] &gt; num) {       num = obj[key]       result = key   }   }</code></pre></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串相关&quot;&gt;&lt;a href=&quot;#字符串相关&quot; class=&quot;headerlink&quot; title=&quot;字符串相关&quot;&gt;&lt;/a&gt;字符串相关&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;给出一个字符串”adadfdfseffqdjhuserfefsefseetsdg”&lt;/
      
    
    </summary>
    
    
      <category term="-JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="-JavaScript算法" scheme="http://yoursite.com/tags/JavaScript%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="http://yoursite.com/2020/06/04/JavaScript/"/>
    <id>http://yoursite.com/2020/06/04/JavaScript/</id>
    <published>2020-06-04T12:25:02.000Z</published>
    <updated>2020-07-28T13:38:16.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h1><ul><li>一个完整的JavaScript实现应该由下列三个不同的部分组成<ul><li>核心（ECMAScript）：提供核心语言功能</li><li>文档对象模型（DOM）：提供访问和操作网页内容的方法和接口</li><li>浏览器对象模型（BOM）：提供与浏览器交互的方法和接口</li></ul></li></ul><hr><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="语法"><a href="#语法" class="headerlink" title="* 语法"></a>* 语法</h2><ul><li>区分大小写：ECMAScript中的一切（变量、函数名和操作符）都区分大小写</li><li>标识符组合规则：<ul><li>第一个字符必须是字母、下划线或$</li><li>其他字符可以是字母、下划线、$、或数字</li><li>按照惯例，标识符采用驼峰大小写格式</li><li>不能把关键字、保留字、true、false、null作为标识符  </li></ul></li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="* 数据类型"></a>* 数据类型</h2><ul><li><p>typeof操作符（检测给定变量的数据类型，返回一个字符串）</p><ul><li>“undefined” –&gt; 值未定义（无论是未声明，还是声明未初始化）</li><li>“boolean” –&gt; 值是布尔值</li><li>“string” –&gt; 值是字符串</li><li>“number” –&gt; 值是数值</li><li>“object” –&gt; 值是对象或null</li><li>“function” –&gt; 值是函数</li></ul></li><li><p>Undefined类型（只有一个值，变量声明，但未初始化，值就是undefined）</p></li><li><p>Null类型（只有一个值，表示一个空对象指针）</p><ul><li>注意：undefined值派生自null值，若判断undefined == null，返回值为true</li></ul></li><li><p>Boolean类型（两个字面值true、false，严格区分大小写）</p><ul><li>任何非空字符串都转换为true,””转换为false</li><li>任何非零数字值转换为true，0或NaN转换为false</li><li>任何对象转换为true，null转换为false</li><li>undefined转换为false</li></ul></li><li><p>Number类型</p><ul><li>八进制字面值的第一位必须是0，在严格模式下是无效的</li><li>十六进制字面值前两位必须是0x</li><li>判断值是不是处于最大值和最小值之间：isFinite(值)</li><li>NaN与任何值都不等，包括本身</li><li>数值转换（Number()用于任何数据类型，parseInt()、parseFloat()用于字符串）</li><li>Number()函数转换规则<ul><li>true –&gt; 1 false –&gt; 0</li><li>数字值 –&gt; 简单的传入和返回</li><li>null –&gt; 0</li><li>undefined –&gt; NaN</li><li>只包含数字的字符串（包括正负号） –&gt; 直接转换成对应数字（忽略前导0）</li><li>包含有效浮点格式的字符串 –&gt; 浮点格式数字</li><li>空字符串 –&gt; 0</li><li>剩余格式 –&gt; NaN</li></ul></li><li>parseInt()转换规则（具有第二个参数：转换使用的进制）<ul><li>“1234blue” –&gt; 1234</li><li>“22.5” –&gt; 22</li></ul></li><li>parseFloat()转换规则<ul><li>“22.2.3” –&gt; 22.2</li><li>“1234blue” –&gt; 1234</li><li>“0xA” –&gt; 0</li></ul></li></ul></li><li><p>String类型</p><ul><li>转义字符<ul><li>\n 换行符</li><li>\t 制表符</li><li>\b 退格</li><li>\r 回车</li></ul></li><li>字符串是不可变的</li><li>转换为字符串<ul><li>调用toString()方法，数字值有第二个参数，指定进制</li><li>null、undefined没有toString()，可以调用String()</li></ul></li></ul></li><li><p>Object类型</p><ul><li>constructor：构造函数，保存着用于创建当前对象的函数</li><li>hasOwnProperty(propertyName)：用于检查给定的属性在当前实例中（而不是在实例的原型中）是否存在</li></ul></li><li><p>语句</p><ul><li><p>for-in语句（精准的迭代语句，可用来枚举对象属性）</p><ul><li>建议迭代前，确认对象不是null或undefined</li></ul></li><li><p>label语句（在代码中添加的标签将来可以引用）</p><pre><code>let num = 0outermost:for(let i = 0; i &lt; 10; i++) {  for(let j = 0; j &lt; 10; j++){    if(i == 5 &amp;&amp; j == 5) {      continue outermost    }    num++  }}</code></pre></li><li><p>with语句（将代码的作用域设置到一个特定的对象中，目的简化多次编写同一个对象的工作，注意：严格模式下不允许使用，并且大量使用会导致性能下降并且调试困难）</p><pre><code>let qs = location.search.substring(1)let hostName = location.hostnamelet url = location.hrefwith(location) {  let qs = search.substring(1)  let hostName = hostname  let url = href}</code></pre></li></ul></li></ul><hr><h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="* 基本类型和引用类型的值"></a>* 基本类型和引用类型的值</h2><ul><li>不能给基本类型的值添加属性，尽管这样做不会导致任何错误</li><li>复制变量值<ul><li>基本类型复制：会在变量对象上创建一个新值，把该值复制到新变量的位置上</li><li>引用类型复制：复制前和复制后的对象实际上引用同一个对象，互相影响</li></ul></li></ul><hr><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="* Object类型"></a>* Object类型</h2><ul><li>创建Object实例的两种方式<ul><li>new操作符后跟Object构造函数<pre><code>var person = new Object()</code></pre></li><li>使用对象字面量表示法<pre><code>var person = {  name: &#39;Kobe&#39;}</code></pre></li></ul></li></ul><hr><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="* Array类型"></a>* Array类型</h2><ul><li><p>创建数组的两种基本方式</p><ul><li>使用Array构造函数（new操作符可省略）<ul><li>知道数组长度<pre><code>var colors = new Array(20)</code></pre></li><li>知道数组所包含的项<pre><code>var colors = new Array(&#39;blue&#39;,&#39;red&#39;,&#39;yellow&#39;)</code></pre></li></ul></li><li>数组字面量表示法<pre><code>var colors = []var colors = [&#39;red&#39;,&#39;yellow&#39;,&#39;yellow&#39;]</code></pre></li></ul></li><li><p>数组的length属性</p><ul><li>该属性不是只读的，也就是说可以通过设置此属性向数组末尾添加或删除项</li></ul></li><li><p>检测数组</p><ul><li>对于一个网页或者一个全局作用而言可以使用<code>instanceof</code>检测是否是数组<pre><code>value instanceof Array</code></pre></li><li>ECMAScript5新增<code>Array.isArray()</code>方法<pre><code>Array.isArray(value)</code></pre></li></ul></li><li><p>栈方法</p><ul><li>入栈：push方法，逐个添加到数组末尾，返回修改后的数组长度<pre><code>var colors = []var count = colors.push(&#39;red&#39;) // 1</code></pre></li><li>出栈：pop方法，从数组末尾移除最后一项，返回移除的项<pre><code>var colors = [&#39;red&#39;,&#39;yellow&#39;,&#39;blue&#39;]var item = colors.pop() // blue </code></pre></li></ul></li><li><p>队列方法</p><ul><li>正反向模拟队列<ul><li>push方法向数组末尾添加项</li><li>shift方法从数组前端取得项</li></ul></li><li>反方向模拟队列<ul><li>unshift方法向数组前端添加项</li><li>pop方法从数组末尾取得项</li></ul></li></ul></li><li><p>重排序方法</p><ul><li>reverse方法反转数组项<pre><code>var values = [1,2,3,4,5]values.reverse() //5,4,3,2,1</code></pre></li><li>sort方法排序（默认是升序，可传入一个比较函数）<pre><code>var values = [0,1,5,10,15]function compare(value1,value2) {  if(value1 &lt; value2) { // 升序    return -1  } else if(value1 &gt; value2) {    return 1  } else {    return 0  }}values.sort(compare)// 简化写法values.sort(function(value1,value2) {  return value2 - value1})</code></pre></li></ul></li><li><p>操作方法（slice方法）</p><ul><li>删除：slice(0,2) –&gt; 参数一：起始位置 参数二：删除的项数</li><li>插入：slice(2,0,’red’,’blue’) –&gt; 参数一：起始位置 参数二：删除的项数 参数三：插入的项</li><li>替换：slice(2,1,’red’,’blue’) –&gt; 参数一：起始位置 参数二：删除的项数 参数三：替换的项</li></ul></li><li><p>位置方法（indexOf、lastIndexOf）</p><ul><li>都接收两个参数：要查找的项、查找起点</li><li>indexOf从前往后，lastIndexOf从后往前</li><li>没找到的情况下返回-1<pre><code>var nums = [1,2,3,4,5,4]console.log(nums.indexOf(2)) // 1console.log(nums.indexOf(4,4)) // 5</code></pre></li></ul><p>var person = {name: ‘Kobe’}<br>var people = [{name: ‘Kobe’}]<br>var morePeople = [person]<br>console.log(people.indexOf(person)) // -1<br>console.log(morePeople.indexOf(person)) // 0<br>```</p></li><li><p>迭代方法</p><ul><li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true<pre><code>var numbers = [1,2,3,4,5,4,3,2,1]var result = numbers.every(function(item, index, array) {  return item &gt; 2})  // result --&gt; false 部分满足返回false</code></pre></li><li>some()：对数组中的每一项运行给定函数，如果该函数对数组某一项返回true，则返回true<pre><code>var numbers = [1,2,3,4,5,4,3,2,1]var result = numbers.some(function(item, index, array) {  return item &gt; 2})  // result --&gt; true 部分满足返回true</code></pre></li><li>filter()：对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组<pre><code>var numbers = [1,2,3,4,5,4,3,2,1]var result = numbers.filter(function(item, index, array) {  return item &gt; 2})  // result --&gt; [3,4,5,4,3] 返回满足条件的项组成的数组</code></pre></li><li>forEach()：对数组中的每一项运行给定函数，本质上与使用for循环迭代数组一样<pre><code>var numbers = [1,2,3,4,5,4,3,2,1]var result = numbers.forEach(function(item, index, array) {  // 执行某些操作})</code></pre></li><li>map()：返回一个数组，这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果<pre><code>var numbers = [1,2,3,4,5,4,3,2,1]var result = numbers.forEach(function(item, index, array) {  return item * 2})  // result --&gt; [2,4,6,8,10,8,6,4,2]</code></pre></li></ul></li><li><p>归并方法</p><ul><li>reduce()：迭代数组所有项，从数组第一项开始，逐个遍历到最后<pre><code>var numbers = [1,2,3,4,5]var sum = numbers.reduce(function(previous,current,index,array) {  return previous + current})  // sum --&gt; 1+2+3+4+5 = 15/*** 注解：* 第一次回调previous是1，current是2；第二次回调previous是3（1+2），current是3（第三项）...*/</code></pre></li><li>reduceRight()：与<code>reduce()</code>相似，但遍历方向相反<pre><code>var numbers = [1,2,3,4,5]var sum = numbers.reduceRight(function(previous,current,index,array) {  return previous + current})  // sum --&gt; 1+2+3+4+5 = 15/*** 注解：* 第一次回调previous是5，current是4；第二次回调previous是9（5+4），current是3（倒数第三项）...*/</code></pre></li></ul></li></ul><hr><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="* RegExp类型"></a>* RegExp类型</h2><ul><li>正则表达式的匹配模式<ul><li>g：表示全局模式，即模式被应用于所有字符串，而非在发现第一个匹配项时立即停止</li><li>i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写</li><li>m：表示多行模式</li></ul></li><li>RegExp实例属性<ul><li>global：布尔值，表示是设置g标志</li><li>ignoreCase：布尔值，表示是否设置了i标志</li><li>lastIndex：整数，表示开始搜索下一个匹配性的字符位置，从0算起</li><li>multiline：布尔值，表示是否设置了m标志</li><li>source：正则表达式的字符串表示</li></ul></li><li>RegExp实例方法<ul><li>exec()：专门为捕获组二设计的，接受一个参数，即要应用模式的字符串，然后返回包含一个匹配项信息的数组；没有匹配项的情况下返回null，包含两个额外的属性：index和input，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串</li><li>test()：接受一个字符串参数，在模式与字符串匹配的情况下返回true，否则，返回false</li></ul></li></ul><hr><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="* Function类型"></a>* Function类型</h2><!-- ## 字符串方法+ ```indexOf()```方法返回字符串中指定文本首次出现的索引（位置）+ ```lastIndexOf()```方法返回指定文本在字符串中最后一次出现的索引（位置）  **注意：如未找到，indexOf()和lastIndexOf()均返回-1**+ ```search()```方法搜索特定值的字符串，并返回匹配的位置+ ```slice()```方法提取部分字符串，可接受负索引  + 参数一：起始索引  + 参数二：终止索引，省略，则提取起始索引往后的内容+ ```substring()```方法类似于```slice()```，不可接受负索引+ ```substr()```方法类似于```slice()```，不同于第二个参数  + 参数一：起始位置  + 参数二：提取内容的长度，省略，则提取起始索引往后的内容+ ```replace()```方法用于替换字符串中的值  + 参数一：要替换的值  + 参数二：用什么替换+ ```toUpperCase()```方法把字符串转换为大写+ ```toLowerCase()```方法把字符串转换为小写+ ```concat()```方法连接两个或多个字符串+ ```trim()```方法去除字符串两端的空白+ ```charAt()```方法返回字符串中指定下标的字符串  + 参数：索引（位置）+ ```charCodeAt()```方法返回字符串中指定索引的字符的unicode编码+ ```split()```方法把字符串转换为数组  + 参数：分隔符，可省略---## 高阶函数+ **Array.prototype.map**  + ```map()```函数会创建一个新的数组，数组中的元素是传进来的回调函数调用原来数组相同位置的元素的返回值  + 传给```map()```的回调函数callback接收三个参数：```element``` ```index``` ```array```+ **Array.prototype.filter**  + ```filter()```函数创建一个新的数组，数组里面存储原数组里面可以通过传进来的callback测试的元素  + 传给```filter()```的回调函数接收三个参数：```element``` ```index``` ```array```+ **Array.prototype.reduce**  + ```reduce```方法用被调用数组的元素依次作为参数调用传进来的callback然后产生一个返回值  + ```reduce```函数接收两个参数：一个是回调函数callback，一个是可选参数作为preValue的初始值  + callback函数接收4个参数：```preValue``` ```currentValue``` ```currentIndex``` ```sourceArray``` -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript实现&quot;&gt;&lt;a href=&quot;#JavaScript实现&quot; class=&quot;headerlink&quot; title=&quot;JavaScript实现&quot;&gt;&lt;/a&gt;JavaScript实现&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个完整的JavaScript实现应该由下列三个
      
    
    </summary>
    
    
      <category term="-JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="-JavaScript高级程序设计（第三版）" scheme="http://yoursite.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89/"/>
    
  </entry>
  
</feed>
